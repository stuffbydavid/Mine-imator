/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2023.03.06 18:22:20 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	void block_load_model_file_event_destroy(Scope<obj_block_load_model_file> self)
	{
		if (self->texture_map != null_)
			ds_map_destroy(self->texture_map);
		for (IntType e = IntType(0); e < self->element_amount; e++)
			withOne (Object, self->element.Value(e), self->id)
				instance_destroy(self);
		
	}
	
	VarType block_load_model_file_texture(Scope<obj_block_load_model_file> self, VarType name, VarType res)
	{
		StringType fn;
		name = string_lower(name);
		if (string_pos(/*"assets/minecraft_"*/ STR(822), name) == IntType(1))
			name = string_replace(name, /*"assets/minecraft_"*/ STR(822), /*"block/"*/ STR(789));
		if (res == null_)
			return name;
		if (string_pos(/*"blocks/"*/ STR(823), name) == IntType(1))
		{
			name = string_replace(name, /*"blocks/"*/ STR(823), /*"block/"*/ STR(789));
			VarType newname = ds_map_find_key(global::legacy_block_texture_name_map, name);
			name = (newname == VarType() ? name : newname);
		}
		fn = global::load_folder + /*"/"*/ STR(16) + ObjType(obj_block_load_model_file, self->id)->name + /*"/"*/ STR(16) + name + /*".png"*/ STR(6);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/"*/ STR(16) + name + /*".png"*/ STR(6);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/"*/ STR(16) + string_replace(name, /*"blocks/"*/ STR(823), /*""*/ STR(0)) + /*".png"*/ STR(6);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/"*/ STR(16) + string_replace(name, /*"block/"*/ STR(789), /*""*/ STR(0)) + /*".png"*/ STR(6);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/"*/ STR(16) + filename_name(name) + /*".png"*/ STR(6);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/../../textures/"*/ STR(824) + name + /*".png"*/ STR(6);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/../../textures/item/"*/ STR(825) + name + /*".png"*/ STR(6);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/../../textures/block/"*/ STR(826) + name + /*".png"*/ STR(6);
		if (!file_exists_lib(fn))
			return name;
		if (idInt(res, model_texture_map) == null_)
			idInt(res, model_texture_map) = ds_map_create();
		else
			if (!is_undefined(DsMap(idInt(res, model_texture_map)).Value(name)))
				return name;
		
		DsMap(idInt(res, model_texture_map))[name] = texture_create_square(fn);
		return name;
	}
	
	IntType block_load_render_model(ScopeAny self, VarArgs argument)
	{
		IntType argument_count = argument.Size();
		VarType model, rot, uvlock, wei, res, opaque;
		MatrixType rotmat;
		IntType modelstate, colY, colZ;
		VarType alphaY, alphaZ;
		model = argument[IntType(0)];
		rot = argument[IntType(1)];
		uvlock = argument[IntType(2)];
		opaque = argument[IntType(3)];
		wei = argument[IntType(4)];
		if (argument_count > IntType(5))
			res = argument[IntType(5)];
		else
			res = null_;
		
		if (res == null_)
		{
			modelstate = sInt(model_state_obj);
			colY = ObjType(obj_block_load_state_file, modelstate)->model_preview_color_yp;
			alphaY = ObjType(obj_block_load_state_file, modelstate)->model_preview_alpha_yp;
			colZ = ObjType(obj_block_load_state_file, modelstate)->model_preview_color_zp;
			alphaZ = ObjType(obj_block_load_state_file, modelstate)->model_preview_alpha_zp;
		}
		else
		{
			modelstate = null_;
			colY = null_;
			alphaY = null_;
			colZ = null_;
			alphaZ = null_;
		}
		
		if (rot.Value(X_) > IntType(0) || rot.Value(Z_) > IntType(0))
		{
			rotmat = matrix_create(point3D(-block_size_ / 2.0, -block_size_ / 2.0, -block_size_ / 2.0), vec3(IntType(0)), vec3(IntType(1)));
			rotmat = matrix_multiply(rotmat, matrix_create(point3D(block_size_ / 2.0, block_size_ / 2.0, block_size_ / 2.0), vec3(-rot.Value(X_), IntType(0), -rot.Value(Z_)), vec3(IntType(1))));
		}
		else
			rotmat = MAT_IDENTITY;
		
		withOne (obj_block_render_model, (new obj_block_render_model)->id, self->id)
		{
			self->rendermodel_id = array_length(VarType::CreateRef(global::block_rendermodels));
			array_add(VarType::CreateRef(global::block_rendermodels), self->id);
			VarType elementmodel;
			IntType texturemap;
			elementmodel = null_;
			texturemap = ds_map_create();
			while (model != null_)
			{
				if (idInt(model, texture_map) != null_)
					ds_map_merge({ texturemap, idInt(model, texture_map), false });
				if (elementmodel == null_ && idInt(model, element_amount) > IntType(0))
					elementmodel = model;
				model = idVar(model, parent);
			}
			
			self->emissive = IntType(0);
			self->random_offset = IntType(0);
			self->random_offset_xy = IntType(0);
			self->offset_x = IntType(0);
			self->offset_y = IntType(0);
			self->offset_z = IntType(0);
			self->weight = wei;
			for (IntType f = IntType(0); f < e_dir_amount; f++)
			{
				self->face_full[f] = false;
				self->face_min[f] = null_;
				self->face_max[f] = null_;
				self->face_min_depth[f] = null_;
			}
			self->preview_color_zp = null_;
			self->preview_alpha_zp = IntType(0);
			self->preview_color_yp = null_;
			self->preview_alpha_yp = IntType(0);
			self->preview_tint = /*""*/ STR(0);
			self->element_amount = IntType(0);
			if (elementmodel != null_)
			{
				for (IntType e = IntType(0); e < idInt(elementmodel, element_amount); e++)
				{
					VarType elem = idArr(elementmodel, element).Value(e);
					withOne (obj_block_render_element, (new obj_block_render_element)->id, self->id)
					{
						self->from = idVar(elem, from);
						self->to = idVar(elem, to);
						ArrType facenewdir, faceuvrot;
						for (IntType f = IntType(0); f < e_dir_amount; f++)
						{
							facenewdir[f] = f;
							faceuvrot[f] = IntType(0);
						}
						self->rotated = idBool(elem, rotated);
						if (self->rotated)
							self->matrix = matrix_multiply(idVar(elem, matrix), rotmat);
						else
							if (rot.Value(X_) > IntType(0) || rot.Value(Z_) > IntType(0))
							{
								self->from = point3D_mul_matrix(idVar(elem, from), rotmat);
								self->to = point3D_mul_matrix(idVar(elem, to), rotmat);
								for (IntType a = X_; a <= Z_; a++)
								{
									RealType mi = min({ self->from.Value(a), self->to.Value(a) });
									RealType ma = max({ self->from.Value(a), self->to.Value(a) });
									self->from[a] = snap(mi, 0.01);
									self->to[a] = snap(ma, 0.01);
								}
								for (IntType _it = 0, _it_max = rot.Value(Z_) / 90.0; _it < _it_max; _it++)
								{
									IntType eastrotdir = facenewdir.Value(e_dir_EAST);
									facenewdir[e_dir_EAST] = facenewdir.Value(e_dir_SOUTH);
									facenewdir[e_dir_SOUTH] = facenewdir.Value(e_dir_WEST);
									facenewdir[e_dir_WEST] = facenewdir.Value(e_dir_NORTH);
									facenewdir[e_dir_NORTH] = eastrotdir;
								}
								for (IntType _it = 0, _it_max = rot.Value(X_) / 90.0; _it < _it_max; _it++)
								{
									IntType uprotdir = facenewdir.Value(e_dir_UP);
									facenewdir[e_dir_UP] = facenewdir.Value(e_dir_NORTH);
									facenewdir[e_dir_NORTH] = facenewdir.Value(e_dir_DOWN);
									facenewdir[e_dir_DOWN] = facenewdir.Value(e_dir_SOUTH);
									facenewdir[e_dir_SOUTH] = uprotdir;
								}
								switch ((IntType)rot.Value(X_))
								{
									case IntType(0):
									{
										faceuvrot[e_dir_UP] = rot.Value(Z_);
										faceuvrot[e_dir_DOWN] = -rot.Value(Z_);
										break;
									}
									
									case IntType(90):
									{
										faceuvrot[facenewdir.Value(e_dir_EAST)] = IntType(90);
										faceuvrot[facenewdir.Value(e_dir_WEST)] = -IntType(90);
										faceuvrot[facenewdir.Value(e_dir_UP)] = IntType(180);
										faceuvrot[e_dir_UP] = rot.Value(Z_);
										faceuvrot[e_dir_DOWN] = IntType(180) - rot.Value(Z_);
										break;
									}
									
									case IntType(180):
									{
										faceuvrot[e_dir_EAST] = IntType(180);
										faceuvrot[e_dir_WEST] = IntType(180);
										faceuvrot[e_dir_SOUTH] = IntType(180);
										faceuvrot[e_dir_NORTH] = IntType(180);
										faceuvrot[e_dir_UP] = rot.Value(Z_);
										faceuvrot[e_dir_DOWN] = -rot.Value(Z_);
										break;
									}
									
									case IntType(270):
									{
										faceuvrot[facenewdir.Value(e_dir_EAST)] = -IntType(90);
										faceuvrot[facenewdir.Value(e_dir_WEST)] = IntType(90);
										faceuvrot[facenewdir.Value(e_dir_DOWN)] = IntType(180);
										faceuvrot[e_dir_UP] = IntType(180) + rot.Value(Z_);
										faceuvrot[e_dir_DOWN] = -rot.Value(Z_);
										break;
									}
									
								}
								
							}
						
						for (IntType f = IntType(0); f < e_dir_amount; f++)
						{
							IntType nd = facenewdir.Value(f);
							self->face_render[nd] = idArr(elem, face_render).Value(f);
							if (!self->face_render.Value(nd))
								continue;
							VarType facerot = idArr(elem, face_rotation).Value(f);
							if (!(uvlock > 0))
								facerot += mod_fix(faceuvrot.Value(nd), IntType(360));
							if (idArr(elem, face_has_uv).Value(f))
							{
								VarType uvfrom, uvto;
								if (uvlock > 0 && faceuvrot.Value(nd) != IntType(0))
								{
									uvfrom = uv_rotate(idArr(elem, face_uv_from).Value(f), -faceuvrot.Value(nd), point2D(block_size_ / 2.0, block_size_ / 2.0));
									uvto = uv_rotate(idArr(elem, face_uv_to).Value(f), -faceuvrot.Value(nd), point2D(block_size_ / 2.0, block_size_ / 2.0));
									for (IntType a = X_; a <= Y_; a++)
									{
										RealType mi = min({ uvfrom.Value(a), uvto.Value(a) });
										RealType ma = max({ uvfrom.Value(a), uvto.Value(a) });
										uvfrom[a] = snap(mi, 0.01);
										uvto[a] = snap(ma, 0.01);
									}
								}
								else
								{
									uvfrom = idArr(elem, face_uv_from).Value(f);
									uvto = idArr(elem, face_uv_to).Value(f);
								}
								
								self->face_uv[nd][IntType(0)] = uvfrom;
								self->face_uv[nd][IntType(1)] = point2D(uvto.Value(X_), uvfrom.Value(Y_));
								self->face_uv[nd][IntType(2)] = uvto;
								self->face_uv[nd][IntType(3)] = point2D(uvfrom.Value(X_), uvto.Value(Y_));
								for (IntType _it = 0, _it_max = (RealType)facerot / 90.0; _it < _it_max; _it++)
								{
									VarType tmp = self->face_uv[nd][IntType(0)];
									self->face_uv[nd][IntType(0)] = self->face_uv[nd][IntType(3)];
									self->face_uv[nd][IntType(3)] = self->face_uv[nd][IntType(2)];
									self->face_uv[nd][IntType(2)] = self->face_uv[nd][IntType(1)];
									self->face_uv[nd][IntType(1)] = tmp;
								}
							}
							else
							{
								switch ((IntType)nd)
								{
									case e_dir_EAST:
									{
										self->face_uv[nd][IntType(0)] = point2D(block_size_ - self->to.Value(Y_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(1)] = point2D(block_size_ - self->from.Value(Y_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(2)] = point2D(block_size_ - self->from.Value(Y_), block_size_ - self->from.Value(Z_));
										self->face_uv[nd][IntType(3)] = point2D(block_size_ - self->to.Value(Y_), block_size_ - self->from.Value(Z_));
										break;
									}
									case e_dir_WEST:
									{
										self->face_uv[nd][IntType(0)] = point2D(self->from.Value(Y_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(1)] = point2D(self->to.Value(Y_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(2)] = point2D(self->to.Value(Y_), block_size_ - self->from.Value(Z_));
										self->face_uv[nd][IntType(3)] = point2D(self->from.Value(Y_), block_size_ - self->from.Value(Z_));
										break;
									}
									case e_dir_SOUTH:
									{
										self->face_uv[nd][IntType(0)] = point2D(self->from.Value(X_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(1)] = point2D(self->to.Value(X_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(2)] = point2D(self->to.Value(X_), block_size_ - self->from.Value(Z_));
										self->face_uv[nd][IntType(3)] = point2D(self->from.Value(X_), block_size_ - self->from.Value(Z_));
										break;
									}
									case e_dir_NORTH:
									{
										self->face_uv[nd][IntType(0)] = point2D(block_size_ - self->to.Value(X_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(1)] = point2D(block_size_ - self->from.Value(X_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(2)] = point2D(block_size_ - self->from.Value(X_), block_size_ - self->from.Value(Z_));
										self->face_uv[nd][IntType(3)] = point2D(block_size_ - self->to.Value(X_), block_size_ - self->from.Value(Z_));
										break;
									}
									case e_dir_UP:
									{
										self->face_uv[nd][IntType(0)] = point2D(self->from.Value(X_), self->from.Value(Y_));
										self->face_uv[nd][IntType(1)] = point2D(self->to.Value(X_), self->from.Value(Y_));
										self->face_uv[nd][IntType(2)] = point2D(self->to.Value(X_), self->to.Value(Y_));
										self->face_uv[nd][IntType(3)] = point2D(self->from.Value(X_), self->to.Value(Y_));
										break;
									}
									case e_dir_DOWN:
									{
										self->face_uv[nd][IntType(0)] = point2D(self->from.Value(X_), block_size_ - self->to.Value(Y_));
										self->face_uv[nd][IntType(1)] = point2D(self->to.Value(X_), block_size_ - self->to.Value(Y_));
										self->face_uv[nd][IntType(2)] = point2D(self->to.Value(X_), block_size_ - self->from.Value(Y_));
										self->face_uv[nd][IntType(3)] = point2D(self->from.Value(X_), block_size_ - self->from.Value(Y_));
										break;
									}
								}
								
								if (facerot > IntType(0))
								{
									self->face_uv[nd][IntType(0)] = uv_rotate(self->face_uv[nd][IntType(0)], facerot, point2D(block_size_ / 2.0, block_size_ / 2.0));
									self->face_uv[nd][IntType(1)] = uv_rotate(self->face_uv[nd][IntType(1)], facerot, point2D(block_size_ / 2.0, block_size_ / 2.0));
									self->face_uv[nd][IntType(2)] = uv_rotate(self->face_uv[nd][IntType(2)], facerot, point2D(block_size_ / 2.0, block_size_ / 2.0));
									self->face_uv[nd][IntType(3)] = uv_rotate(self->face_uv[nd][IntType(3)], facerot, point2D(block_size_ / 2.0, block_size_ / 2.0));
								}
							}
							
							for (IntType i = IntType(0); i < IntType(4); i++)
							{
								VarType fuv = self->face_uv[nd][i];
								fuv[X_] = min({ block_size_ - 1.0 / 256.0, fuv.Value(X_) });
								fuv[Y_] = min({ block_size_ - 1.0 / 256.0, fuv.Value(Y_) });
								self->face_uv[nd][i] = fuv;
							}
							VarType texname;
							VecType texpos, texsize;
							if (uvlock > 0 && idArr(elem, face_render).Value(nd))
								texname = idArr(elem, face_texture).Value(nd);
							else
								texname = idArr(elem, face_texture).Value(f);
							
							while (string_char_at(texname, IntType(1)) == /*"#"*/ STR(827))
							{
								texname = string_delete(texname, IntType(1), IntType(1));
								if (is_undefined(DsMap(texturemap).Value(texname)))
								{
									log({ /*"Could not find block texture"*/ STR(828), texname });
									texname = /*""*/ STR(0);
									break;
								}
								texname = DsMap(texturemap).Value(texname);
							}
							
							if (texname == /*""*/ STR(0))
							{
								self->face_render[nd] = false;
								continue;
							}
							self->face_texture_color[nd] = -IntType(1);
							if (res != null_ && idInt(res, model_texture_map) != null_ && !is_undefined(DsMap(idInt(res, model_texture_map)).Value(texname)))
							{
								self->face_depth[nd] = e_block_depth_DEPTH2;
								self->face_block_vbuffer[nd] = null_;
								self->face_vbuffer[nd] = DsMap(idInt(res, model_block_map)).Value(texname);
								if (is_undefined(self->face_vbuffer.Value(nd)))
								{
									self->face_vbuffer[nd] = vbuffer_start();
									DsMap(idInt(res, model_block_map))[texname] = self->face_vbuffer.Value(nd);
								}
								texpos = vec2(IntType(0), IntType(0));
								texsize = vec2(block_size_, block_size_);
							}
							else
							{
								IntType slot;
								RealType sheetwidth, sheetheight;
								slot = -IntType(1);
								self->face_vbuffer[nd] = null_;
								if (opaque > 0)
									slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_list), texname + /*" opaque"*/ STR(829));
								if (slot < IntType(0))
									slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_list), texname + /*" noalpha"*/ STR(830));
								if (slot < IntType(0))
									slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_list), texname);
								if (slot < IntType(0))
								{
									if (slot < IntType(0))
										slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_ani_list), texname);
									if (slot < IntType(0))
										slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_list), texname + /*" noalpha"*/ STR(830));
									if (slot < IntType(0))
										slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_ani_list), texname + /*" opaque"*/ STR(829));
									if (slot < IntType(0))
									{
										self->face_render[nd] = false;
										continue;
									}
									self->face_depth[nd] = DsList(ObjType(obj_resource, global::mc_res)->block_sheet_ani_depth_list).Value(slot);
									self->face_block_vbuffer[nd] = e_block_vbuffer_ANIMATED;
									VarType col = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_color_map).Value(texname);
									if (!is_undefined(col) && col == /*"water"*/ STR(785))
										self->face_block_vbuffer[nd] = e_block_vbuffer_WATER;
									sheetwidth = block_sheet_ani_width;
									sheetheight = block_sheet_ani_height;
								}
								else
								{
									self->face_depth[nd] = DsList(ObjType(obj_resource, global::mc_res)->block_sheet_depth_list).Value(slot);
									self->face_block_vbuffer[nd] = e_block_vbuffer_NORMAL;
									sheetwidth = block_sheet_width;
									sheetheight = block_sheet_height;
									VarType col = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_color_map).Value(texname);
									if (!is_undefined(col))
									{
										if (is_real(col))
											self->face_texture_color[nd] = col;
										else
										{
											switch (StringType(col).id)
											{
												case 831: // grass
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_GRASS;
													break;
												}
												case 832: // foliage
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_FOLIAGE;
													break;
												}
												case 833: // oak_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_OAK;
													break;
												}
												case 834: // spruce_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_SPRUCE;
													break;
												}
												case 835: // birch_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_BIRCH;
													break;
												}
												case 836: // jungle_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_JUNGLE;
													break;
												}
												case 837: // acacia_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_ACACIA;
													break;
												}
												case 838: // dark_oak_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_DARK_OAK;
													break;
												}
												case 839: // mangrove_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_MANGROVE;
													break;
												}
											}
											
										}
										
									}
								}
								
								texpos = point2D((mod(slot, sheetwidth)) * block_size_, ((IntType)(slot / sheetwidth)) * block_size_);
								texsize = vec2(sheetwidth * block_size_, sheetheight * block_size_);
								if (res == null_)
								{
									if ((nd == e_dir_UP && ObjType(obj_block_render_model, self.otherId)->preview_color_zp == null_ && alphaZ != IntType(0)) || (nd == e_dir_SOUTH && ObjType(obj_block_render_model, self.otherId)->preview_color_yp == null_ && alphaY != IntType(0)))
									{
										if (self->face_block_vbuffer.Value(nd) == e_block_vbuffer_ANIMATED || self->face_block_vbuffer.Value(nd) == e_block_vbuffer_WATER)
											global::buffer_current = global::load_assets_block_preview_ani_buffer;
										else
											global::buffer_current = global::load_assets_block_preview_buffer;
										
										RealType px, py;
										VarType alpha;
										IntType col;
										px = mod(slot, sheetwidth);
										py = (IntType)(slot / sheetwidth);
										if ((nd == e_dir_UP && alphaZ == -IntType(1)) || (nd == e_dir_SOUTH && alphaY == -IntType(1)))
											alpha = buffer_read_alpha(px, py, sheetwidth);
										else
											alpha = (nd == e_dir_UP ? alphaZ : alphaY);
										
										if (alpha > IntType(0))
										{
											if ((nd == e_dir_UP && colZ == -IntType(1)) || (nd == e_dir_SOUTH && colY == -IntType(1)))
												col = buffer_read_color(px, py, sheetwidth);
											else
												col = (nd == e_dir_UP ? colZ : colY);
											
											if (self->face_texture_color.Value(nd) > -IntType(1))
												col = color_multiply(col, self->face_texture_color.Value(nd));
											else
											{
												VarType rescol;
												StringType colstr;
												rescol = null_;
												colstr = /*""*/ STR(0);
												switch ((IntType)self->face_block_vbuffer.Value(nd))
												{
													case e_block_vbuffer_GRASS:
													{
														colstr = /*"grass"*/ STR(831);
														break;
													}
													case e_block_vbuffer_FOLIAGE:
													{
														colstr = /*"foliage"*/ STR(832);
														break;
													}
													case e_block_vbuffer_WATER:
													{
														colstr = /*"water"*/ STR(785);
														break;
													}
													case e_block_vbuffer_LEAVES_OAK:
													{
														colstr = /*"foliage"*/ STR(832);
														break;
													}
													case e_block_vbuffer_LEAVES_SPRUCE:
													{
														rescol = ObjType(obj_resource, global::mc_res)->color_leaves_spruce;
														break;
													}
													case e_block_vbuffer_LEAVES_BIRCH:
													{
														rescol = ObjType(obj_resource, global::mc_res)->color_leaves_birch;
														break;
													}
													case e_block_vbuffer_LEAVES_JUNGLE:
													{
														colstr = /*"foliage"*/ STR(832);
														break;
													}
													case e_block_vbuffer_LEAVES_ACACIA:
													{
														colstr = /*"foliage"*/ STR(832);
														break;
													}
													case e_block_vbuffer_LEAVES_DARK_OAK:
													{
														colstr = /*"foliage"*/ STR(832);
														break;
													}
													case e_block_vbuffer_LEAVES_MANGROVE:
													{
														colstr = /*"foliage"*/ STR(832);
														break;
													}
												}
												
												if (rescol != null_)
													col = color_multiply(rescol, col);
												ObjType(obj_block_render_model, self.otherId)->preview_tint = colstr;
											}
											
											if (nd == e_dir_UP)
											{
												ObjType(obj_block_render_model, self.otherId)->preview_color_zp = col;
												ObjType(obj_block_render_model, self.otherId)->preview_alpha_zp = alpha;
											}
											else
											{
												ObjType(obj_block_render_model, self.otherId)->preview_color_yp = col;
												ObjType(obj_block_render_model, self.otherId)->preview_alpha_yp = alpha;
											}
											
										}
									}
								}
							}
							
							for (IntType t = IntType(0); t < IntType(4); t++)
								self->face_uv[nd][t] = vec2_div(point2D_add(self->face_uv[nd][t], texpos), texsize);
							self->face_edge[nd] = false;
							if (!self->rotated)
							{
								switch ((IntType)nd)
								{
									case e_dir_EAST:
									case e_dir_WEST:
									{
										if (nd == e_dir_EAST)
											self->face_edge[nd] = (self->to.Value(X_) == block_size_);
										else
											self->face_edge[nd] = (self->from.Value(X_) == IntType(0));
										
										if (self->face_edge.Value(nd) && !ObjType(obj_block_render_model, self.otherId)->face_full.Value(nd))
										{
											if (self->from.Value(Y_) == IntType(0) && self->to.Value(Y_) == block_size_)
											{
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == null_ || self->from.Value(Z_) <= ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_min[nd] = self->from.Value(Z_);
												if (ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == null_ || self->to.Value(Z_) >= ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_max[nd] = self->to.Value(Z_);
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == IntType(0) && ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == block_size_)
													ObjType(obj_block_render_model, self.otherId)->face_full[nd] = true;
											}
											if (ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd) == null_ || self->face_depth.Value(nd) < ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd))
												ObjType(obj_block_render_model, self.otherId)->face_min_depth[nd] = self->face_depth.Value(nd);
										}
										break;
									}
									
									case e_dir_SOUTH:
									case e_dir_NORTH:
									{
										if (nd == e_dir_SOUTH)
											self->face_edge[nd] = (self->to.Value(Y_) == block_size_);
										else
											self->face_edge[nd] = (self->from.Value(Y_) == IntType(0));
										
										if (self->face_edge.Value(nd) && !ObjType(obj_block_render_model, self.otherId)->face_full.Value(nd))
										{
											if (self->from.Value(X_) == IntType(0) && self->to.Value(X_) == block_size_)
											{
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == null_ || self->from.Value(Z_) <= ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_min[nd] = self->from.Value(Z_);
												if (ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == null_ || self->to.Value(Z_) >= ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_max[nd] = self->to.Value(Z_);
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == IntType(0) && ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == block_size_)
													ObjType(obj_block_render_model, self.otherId)->face_full[nd] = true;
											}
											if (ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd) == null_ || self->face_depth.Value(nd) < ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd))
												ObjType(obj_block_render_model, self.otherId)->face_min_depth[nd] = self->face_depth.Value(nd);
										}
										break;
									}
									
									case e_dir_UP:
									case e_dir_DOWN:
									{
										if (nd == e_dir_UP)
											self->face_edge[nd] = (self->to.Value(Z_) == block_size_);
										else
											self->face_edge[nd] = (self->from.Value(Z_) == IntType(0));
										
										if (self->face_edge.Value(nd) && !ObjType(obj_block_render_model, self.otherId)->face_full.Value(nd))
										{
											if (self->from.Value(X_) == IntType(0) && self->to.Value(X_) == block_size_)
											{
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == null_ || self->from.Value(Y_) <= ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_min[nd] = self->from.Value(Y_);
												if (ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == null_ || self->to.Value(Y_) >= ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_max[nd] = self->to.Value(Y_);
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == IntType(0) && ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == block_size_)
													ObjType(obj_block_render_model, self.otherId)->face_full[nd] = true;
											}
											if (ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd) == null_ || self->face_depth.Value(nd) < ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd))
												ObjType(obj_block_render_model, self.otherId)->face_min_depth[nd] = self->face_depth.Value(nd);
										}
										break;
									}
									
								}
								
							}
						}
						self->from_x = self->from.Value(X_);
						self->from_y = self->from.Value(Y_);
						self->from_z = self->from.Value(Z_);
						self->to_x = self->to.Value(X_);
						self->to_y = self->to.Value(Y_);
						self->to_z = self->to.Value(Z_);
						self->face_render_xp = self->face_render.Value(e_dir_EAST);
						self->face_render_xn = self->face_render.Value(e_dir_WEST);
						self->face_render_yp = self->face_render.Value(e_dir_SOUTH);
						self->face_render_yn = self->face_render.Value(e_dir_NORTH);
						self->face_render_zp = self->face_render.Value(e_dir_UP);
						self->face_render_zn = self->face_render.Value(e_dir_DOWN);
						if (self->face_render_xp > 0)
						{
							self->face_texture_color_xp = self->face_texture_color.Value(e_dir_EAST);
							self->face_depth_xp = self->face_depth.Value(e_dir_EAST);
							self->face_block_vbuffer_xp = self->face_block_vbuffer.Value(e_dir_EAST);
							self->face_vbuffer_xp = self->face_vbuffer.Value(e_dir_EAST);
							self->face_edge_xp = self->face_edge.Value(e_dir_EAST);
							self->face_uv_xp_0 = self->face_uv[e_dir_EAST][IntType(0)];
							self->face_uv_xp_0_x = self->face_uv_xp_0.Value(X_);
							self->face_uv_xp_0_y = self->face_uv_xp_0.Value(Y_);
							self->face_uv_xp_1 = self->face_uv[e_dir_EAST][IntType(1)];
							self->face_uv_xp_1_x = self->face_uv_xp_1.Value(X_);
							self->face_uv_xp_1_y = self->face_uv_xp_1.Value(Y_);
							self->face_uv_xp_2 = self->face_uv[e_dir_EAST][IntType(2)];
							self->face_uv_xp_2_x = self->face_uv_xp_2.Value(X_);
							self->face_uv_xp_2_y = self->face_uv_xp_2.Value(Y_);
							self->face_uv_xp_3 = self->face_uv[e_dir_EAST][IntType(3)];
							self->face_uv_xp_3_x = self->face_uv_xp_3.Value(X_);
							self->face_uv_xp_3_y = self->face_uv_xp_3.Value(Y_);
						}
						if (self->face_render_xn > 0)
						{
							self->face_texture_color_xn = self->face_texture_color.Value(e_dir_WEST);
							self->face_depth_xn = self->face_depth.Value(e_dir_WEST);
							self->face_block_vbuffer_xn = self->face_block_vbuffer.Value(e_dir_WEST);
							self->face_vbuffer_xn = self->face_vbuffer.Value(e_dir_WEST);
							self->face_edge_xn = self->face_edge.Value(e_dir_WEST);
							self->face_uv_xn_0 = self->face_uv[e_dir_WEST][IntType(0)];
							self->face_uv_xn_0_x = self->face_uv_xn_0.Value(X_);
							self->face_uv_xn_0_y = self->face_uv_xn_0.Value(Y_);
							self->face_uv_xn_1 = self->face_uv[e_dir_WEST][IntType(1)];
							self->face_uv_xn_1_x = self->face_uv_xn_1.Value(X_);
							self->face_uv_xn_1_y = self->face_uv_xn_1.Value(Y_);
							self->face_uv_xn_2 = self->face_uv[e_dir_WEST][IntType(2)];
							self->face_uv_xn_2_x = self->face_uv_xn_2.Value(X_);
							self->face_uv_xn_2_y = self->face_uv_xn_2.Value(Y_);
							self->face_uv_xn_3 = self->face_uv[e_dir_WEST][IntType(3)];
							self->face_uv_xn_3_x = self->face_uv_xn_3.Value(X_);
							self->face_uv_xn_3_y = self->face_uv_xn_3.Value(Y_);
						}
						if (self->face_render_yp > 0)
						{
							self->face_texture_color_yp = self->face_texture_color.Value(e_dir_SOUTH);
							self->face_depth_yp = self->face_depth.Value(e_dir_SOUTH);
							self->face_block_vbuffer_yp = self->face_block_vbuffer.Value(e_dir_SOUTH);
							self->face_vbuffer_yp = self->face_vbuffer.Value(e_dir_SOUTH);
							self->face_edge_yp = self->face_edge.Value(e_dir_SOUTH);
							self->face_uv_yp_0 = self->face_uv[e_dir_SOUTH][IntType(0)];
							self->face_uv_yp_0_x = self->face_uv_yp_0.Value(X_);
							self->face_uv_yp_0_y = self->face_uv_yp_0.Value(Y_);
							self->face_uv_yp_1 = self->face_uv[e_dir_SOUTH][IntType(1)];
							self->face_uv_yp_1_x = self->face_uv_yp_1.Value(X_);
							self->face_uv_yp_1_y = self->face_uv_yp_1.Value(Y_);
							self->face_uv_yp_2 = self->face_uv[e_dir_SOUTH][IntType(2)];
							self->face_uv_yp_2_x = self->face_uv_yp_2.Value(X_);
							self->face_uv_yp_2_y = self->face_uv_yp_2.Value(Y_);
							self->face_uv_yp_3 = self->face_uv[e_dir_SOUTH][IntType(3)];
							self->face_uv_yp_3_x = self->face_uv_yp_3.Value(X_);
							self->face_uv_yp_3_y = self->face_uv_yp_3.Value(Y_);
						}
						if (self->face_render_yn > 0)
						{
							self->face_texture_color_yn = self->face_texture_color.Value(e_dir_NORTH);
							self->face_depth_yn = self->face_depth.Value(e_dir_NORTH);
							self->face_block_vbuffer_yn = self->face_block_vbuffer.Value(e_dir_NORTH);
							self->face_vbuffer_yn = self->face_vbuffer.Value(e_dir_NORTH);
							self->face_edge_yn = self->face_edge.Value(e_dir_NORTH);
							self->face_uv_yn_0 = self->face_uv[e_dir_NORTH][IntType(0)];
							self->face_uv_yn_0_x = self->face_uv_yn_0.Value(X_);
							self->face_uv_yn_0_y = self->face_uv_yn_0.Value(Y_);
							self->face_uv_yn_1 = self->face_uv[e_dir_NORTH][IntType(1)];
							self->face_uv_yn_1_x = self->face_uv_yn_1.Value(X_);
							self->face_uv_yn_1_y = self->face_uv_yn_1.Value(Y_);
							self->face_uv_yn_2 = self->face_uv[e_dir_NORTH][IntType(2)];
							self->face_uv_yn_2_x = self->face_uv_yn_2.Value(X_);
							self->face_uv_yn_2_y = self->face_uv_yn_2.Value(Y_);
							self->face_uv_yn_3 = self->face_uv[e_dir_NORTH][IntType(3)];
							self->face_uv_yn_3_x = self->face_uv_yn_3.Value(X_);
							self->face_uv_yn_3_y = self->face_uv_yn_3.Value(Y_);
						}
						if (self->face_render_zp > 0)
						{
							self->face_texture_color_zp = self->face_texture_color.Value(e_dir_UP);
							self->face_depth_zp = self->face_depth.Value(e_dir_UP);
							self->face_block_vbuffer_zp = self->face_block_vbuffer.Value(e_dir_UP);
							self->face_vbuffer_zp = self->face_vbuffer.Value(e_dir_UP);
							self->face_edge_zp = self->face_edge.Value(e_dir_UP);
							self->face_uv_zp_0 = self->face_uv[e_dir_UP][IntType(0)];
							self->face_uv_zp_0_x = self->face_uv_zp_0.Value(X_);
							self->face_uv_zp_0_y = self->face_uv_zp_0.Value(Y_);
							self->face_uv_zp_1 = self->face_uv[e_dir_UP][IntType(1)];
							self->face_uv_zp_1_x = self->face_uv_zp_1.Value(X_);
							self->face_uv_zp_1_y = self->face_uv_zp_1.Value(Y_);
							self->face_uv_zp_2 = self->face_uv[e_dir_UP][IntType(2)];
							self->face_uv_zp_2_x = self->face_uv_zp_2.Value(X_);
							self->face_uv_zp_2_y = self->face_uv_zp_2.Value(Y_);
							self->face_uv_zp_3 = self->face_uv[e_dir_UP][IntType(3)];
							self->face_uv_zp_3_x = self->face_uv_zp_3.Value(X_);
							self->face_uv_zp_3_y = self->face_uv_zp_3.Value(Y_);
						}
						if (self->face_render_zn > 0)
						{
							self->face_texture_color_zn = self->face_texture_color.Value(e_dir_DOWN);
							self->face_depth_zn = self->face_depth.Value(e_dir_DOWN);
							self->face_block_vbuffer_zn = self->face_block_vbuffer.Value(e_dir_DOWN);
							self->face_vbuffer_zn = self->face_vbuffer.Value(e_dir_DOWN);
							self->face_edge_zn = self->face_edge.Value(e_dir_DOWN);
							self->face_uv_zn_0 = self->face_uv[e_dir_DOWN][IntType(0)];
							self->face_uv_zn_0_x = self->face_uv_zn_0.Value(X_);
							self->face_uv_zn_0_y = self->face_uv_zn_0.Value(Y_);
							self->face_uv_zn_1 = self->face_uv[e_dir_DOWN][IntType(1)];
							self->face_uv_zn_1_x = self->face_uv_zn_1.Value(X_);
							self->face_uv_zn_1_y = self->face_uv_zn_1.Value(Y_);
							self->face_uv_zn_2 = self->face_uv[e_dir_DOWN][IntType(2)];
							self->face_uv_zn_2_x = self->face_uv_zn_2.Value(X_);
							self->face_uv_zn_2_y = self->face_uv_zn_2.Value(Y_);
							self->face_uv_zn_3 = self->face_uv[e_dir_DOWN][IntType(3)];
							self->face_uv_zn_3_x = self->face_uv_zn_3.Value(X_);
							self->face_uv_zn_3_y = self->face_uv_zn_3.Value(Y_);
						}
						ObjType(obj_block_render_model, self.otherId)->element[ObjType(obj_block_render_model, self.otherId)->element_amount++] = self->id;
					}
					
				}
			}
			self->face_full_xp = self->face_full.Value(e_dir_EAST);
			self->face_min_xp = self->face_min.Value(e_dir_EAST);
			self->face_max_xp = self->face_max.Value(e_dir_EAST);
			self->face_min_depth_xp = self->face_min_depth.Value(e_dir_EAST);
			self->face_full_xn = self->face_full.Value(e_dir_WEST);
			self->face_min_xn = self->face_min.Value(e_dir_WEST);
			self->face_max_xn = self->face_max.Value(e_dir_WEST);
			self->face_min_depth_xn = self->face_min_depth.Value(e_dir_WEST);
			self->face_full_yp = self->face_full.Value(e_dir_SOUTH);
			self->face_min_yp = self->face_min.Value(e_dir_SOUTH);
			self->face_max_yp = self->face_max.Value(e_dir_SOUTH);
			self->face_min_depth_yp = self->face_min_depth.Value(e_dir_SOUTH);
			self->face_full_yn = self->face_full.Value(e_dir_NORTH);
			self->face_min_yn = self->face_min.Value(e_dir_NORTH);
			self->face_max_yn = self->face_max.Value(e_dir_NORTH);
			self->face_min_depth_yn = self->face_min_depth.Value(e_dir_NORTH);
			self->face_full_zp = self->face_full.Value(e_dir_UP);
			self->face_min_zp = self->face_min.Value(e_dir_UP);
			self->face_max_zp = self->face_max.Value(e_dir_UP);
			self->face_min_depth_zp = self->face_min_depth.Value(e_dir_UP);
			self->face_full_zn = self->face_full.Value(e_dir_DOWN);
			self->face_min_zn = self->face_min.Value(e_dir_DOWN);
			self->face_max_zn = self->face_max.Value(e_dir_DOWN);
			self->face_min_depth_zn = self->face_min_depth.Value(e_dir_DOWN);
			ds_map_destroy(texturemap);
			return self->id;
		}
		
		return IntType(0);
	}
	
	VarType block_load_state_file(StringType fname, IntType block, ArrType state)
	{
		if (!file_exists_lib(fname))
		{
			log({ /*"Could not find state file"*/ STR(840), filename_name(fname) });
			return null_;
		}
		IntType jsontypemap, map;
		jsontypemap = ds_int_map_create();
		map = json_load({ fname, jsontypemap });
		if (!ds_map_valid(map))
		{
			log({ /*"Could not parse state file"*/ STR(841), filename_name(fname) });
			ds_map_destroy(jsontypemap);
			return null_;
		}
		VarType variantsmap, multipartlist;
		variantsmap = DsMap(map).Value(/*"variants"*/ STR(842));
		multipartlist = DsMap(map).Value(/*"multipart"*/ STR(843));
		if (!ds_map_valid(variantsmap) && !ds_list_valid(multipartlist))
		{
			log({ /*"No models in the states file"*/ STR(844), fname });
			ds_map_destroy(map);
			return null_;
		}
		withOne (obj_block_load_state_file, (new obj_block_load_state_file)->id, noone)
		{
			self->name = filename_name(fname);
			self->state_id_map = ds_map_create();
			self->state_default_variant_id = IntType(0);
			self->model_preview_color_yp = -IntType(1);
			self->model_preview_alpha_yp = -IntType(1);
			self->model_preview_color_zp = -IntType(1);
			self->model_preview_alpha_zp = -IntType(1);
			if (ds_map_valid(DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_preview_map).Value(sVar(name))))
			{
				VarType blockmap = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_preview_map).Value(sVar(name));
				if (DsMap(blockmap).Value(/*"colorZ"*/ STR(845)) != VarType())
				{
					if (is_string(DsMap(blockmap).Value(/*"colorZ"*/ STR(845))))
						self->model_preview_color_yp = hex_to_color(DsMap(blockmap).Value(/*"colorZ"*/ STR(845)));
					else
					{
						self->model_preview_color_yp = null_;
						self->model_preview_alpha_yp = null_;
					}
					
				}
				if (self->model_preview_alpha_yp != null_ && DsMap(blockmap).Value(/*"alphaZ"*/ STR(846)) != VarType())
					self->model_preview_alpha_yp = DsMap(blockmap).Value(/*"alphaZ"*/ STR(846));
				if (DsMap(blockmap).Value(/*"colorY"*/ STR(847)) != VarType())
				{
					if (is_string(DsMap(blockmap).Value(/*"colorY"*/ STR(847))))
						self->model_preview_color_zp = hex_to_color(DsMap(blockmap).Value(/*"colorY"*/ STR(847)));
					else
					{
						self->model_preview_color_zp = null_;
						self->model_preview_alpha_zp = null_;
					}
					
				}
				if (self->model_preview_alpha_zp != null_ && DsMap(blockmap).Value(/*"alphaY"*/ STR(848)) != VarType())
					self->model_preview_alpha_zp = DsMap(blockmap).Value(/*"alphaY"*/ STR(848));
			}
			BoolType first_state = true;
			if (ds_map_valid(variantsmap))
			{
				VarType variant = ds_map_find_first((IntType)(variantsmap));
				while (!is_undefined(variant))
				{
					withOne (obj_block_load_variant, (new obj_block_load_variant)->id, self->id)
					{
						if (variant != /*""*/ STR(0) && variant != /*"normal"*/ STR(601))
						{
							VarType vars = string_get_state_vars(variant);
							if (vars == null_)
							{
								instance_destroy(ScopeAny(self));
								break;
							}
							state_vars_add(VarType::CreateRef(vars), state);
							DsMap(ObjType(obj_block_load_state_file, self.otherId)->state_id_map)[block_get_state_id(block, vars)] = self->id;
							if (first_state)
								ObjType(obj_block_load_state_file, self.otherId)->state_default_variant_id = block_get_state_id(block, vars);
						}
						else
							DsMap(ObjType(obj_block_load_state_file, self.otherId)->state_id_map)[IntType(0)] = self->id;
						
						first_state = false;
						self->model_amount = IntType(0);
						self->total_weight = IntType(0);
						if (ds_map_find_value((IntType)(DsMap(jsontypemap).Value(variantsmap)), variant) == e_json_type_ARRAY)
						{
							VarType modellist = DsMap(variantsmap).Value(variant);
							for (IntType i = IntType(0); i < ds_list_size((IntType)(modellist)); i++)
								if (!block_load_variant_model(ScopeAny(self), DsList(modellist).Value(i), ObjType(obj_block, block)->type))
									return false;
						}
						else
							if (!block_load_variant_model(ScopeAny(self), DsMap(variantsmap).Value(variant), ObjType(obj_block, block)->type))
								return null_;
						
					}
					
					variant = ds_map_find_next((IntType)(variantsmap), variant);
				}
				
			}
			else
				if (ds_list_valid(multipartlist))
				{
					for (IntType c = IntType(0); c < ds_list_size((IntType)(multipartlist)); c++)
					{
						VarType mcase = DsList(multipartlist).Value(c);
						withOne (obj_block_load_multipart_case, (new obj_block_load_multipart_case)->id, self->id)
						{
							VarType whenmap = DsMap(mcase).Value(/*"when"*/ STR(849));
							if (ds_map_valid(whenmap) && ds_map_size((IntType)(whenmap)) > IntType(0))
							{
								VarType orlist = DsMap(whenmap).Value(/*"OR"*/ STR(850));
								if (ds_list_valid(orlist))
								{
									for (IntType oc = IntType(0); oc < ds_list_size((IntType)(orlist)); oc++)
									{
										VarType curcondmap, cond;
										ArrType condvars;
										curcondmap = DsList(orlist).Value(oc);
										condvars = ArrType();
										cond = ds_map_find_first((IntType)(curcondmap));
										while (!is_undefined(cond))
										{
											VarType val = DsMap(curcondmap).Value(cond);
											if (ds_map_find_value((IntType)(DsMap(jsontypemap).Value(curcondmap)), cond) == e_json_type_BOOL)
												val = ((val > 0) ? /*"true"*/ STR(745) : /*"false"*/ STR(746));
											if (string_contains(val, /*"|"*/ STR(851)))
												state_vars_set_value(VarType::CreateRef(condvars), cond, string_split(val, /*"|"*/ STR(851)));
											else
												state_vars_set_value(VarType::CreateRef(condvars), cond, val);
											
											cond = ds_map_find_next((IntType)(curcondmap), cond);
										}
										
										for (IntType i = IntType(0); i < ObjType(obj_block, block)->state_id_amount; i++)
											if (state_vars_match_state_id(condvars, block, i))
												DsMap(ObjType(obj_block_load_state_file, self.otherId)->state_id_map)[i] = array_add(VarType::CreateRef(DsMap(ObjType(obj_block_load_state_file, self.otherId)->state_id_map)[i]), self->id);
									}
								}
								else
								{
									ArrType condvars;
									VarType cond;
									condvars = ArrType();
									cond = ds_map_find_first((IntType)(whenmap));
									while (!is_undefined(cond))
									{
										VarType val = DsMap(whenmap).Value(cond);
										if (ds_map_find_value((IntType)(DsMap(jsontypemap).Value(whenmap)), cond) == e_json_type_BOOL)
											val = ((val > 0) ? /*"true"*/ STR(745) : /*"false"*/ STR(746));
										if (string_contains(val, /*"|"*/ STR(851)))
											state_vars_set_value(VarType::CreateRef(condvars), cond, string_split(val, /*"|"*/ STR(851)));
										else
											state_vars_set_value(VarType::CreateRef(condvars), cond, val);
										
										cond = ds_map_find_next((IntType)(whenmap), cond);
									}
									
									for (IntType i = IntType(0); i < ObjType(obj_block, block)->state_id_amount; i++)
									{
										if (state_vars_match_state_id(condvars, block, i))
										{
											DsMap(ObjType(obj_block_load_state_file, self.otherId)->state_id_map)[i] = array_add(VarType::CreateRef(DsMap(ObjType(obj_block_load_state_file, self.otherId)->state_id_map)[i]), self->id);
											if (first_state)
											{
												ObjType(obj_block_load_state_file, self.otherId)->state_default_variant_id = i;
												first_state = false;
											}
										}
									}
								}
								
							}
							else
							{
								for (IntType i = IntType(0); i < ObjType(obj_block, block)->state_id_amount; i++)
								{
									DsMap(ObjType(obj_block_load_state_file, self.otherId)->state_id_map)[i] = array_add(VarType::CreateRef(DsMap(ObjType(obj_block_load_state_file, self.otherId)->state_id_map)[i]), self->id);
									if (first_state)
									{
										ObjType(obj_block_load_state_file, self.otherId)->state_default_variant_id = i;
										first_state = false;
									}
								}
							}
							
							self->model_amount = IntType(0);
							self->total_weight = IntType(0);
							if (ds_map_find_value((IntType)(DsMap(jsontypemap).Value(mcase)), /*"apply"*/ STR(852)) == e_json_type_ARRAY)
							{
								VarType modellist = DsMap(mcase).Value(/*"apply"*/ STR(852));
								for (IntType i = IntType(0); i < ds_list_size((IntType)(modellist)); i++)
									if (!block_load_variant_model(ScopeAny(self), DsList(modellist).Value(i), ObjType(obj_block, block)->type))
										return false;
							}
							else
								if (!block_load_variant_model(ScopeAny(self), DsMap(mcase).Value(/*"apply"*/ STR(852)), ObjType(obj_block, block)->type))
									return null_;
							
						}
						
					}
				}
			
			DsMap(global::load_assets_state_file_map)[filename_name(fname)] = self->id;
			ds_map_destroy(jsontypemap);
			return self->id;
		}
		
		return VarType();
	}
	
}
