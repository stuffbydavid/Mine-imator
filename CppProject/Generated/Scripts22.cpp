/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2023.08.25 12:18:13 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	VarType block_load_model_file(StringType fname, IntType res)
	{
		if (res == null_ && !is_undefined(DsMap(global::load_assets_model_file_map).Value(filename_name(fname))))
			return DsMap(global::load_assets_model_file_map).Value(filename_name(fname));
		if (!file_exists_lib(fname))
		{
			log({ /*"Could not find model file"*/ STR(809), fname });
			return null_;
		}
		IntType typemap, map;
		typemap = ds_int_map_create();
		map = json_load({ fname, typemap });
		if (!ds_map_valid(map))
		{
			log({ /*"Could not parse model file"*/ STR(810), fname });
			ds_map_destroy(typemap);
			return null_;
		}
		withOne (obj_block_load_model_file, (new obj_block_load_model_file)->id, noone)
		{
			self->name = filename_new_ext(filename_name(fname), /*""*/ STR(0));
			self->parent = null_;
			if (res == null_ && is_string(DsMap(map).Value(/*"parent"*/ STR(811))))
				self->parent = block_load_model_file(global::load_assets_dir + mc_models_directory + string_replace(DsMap(map).Value(/*"parent"*/ STR(811)), /*"minecraft:"*/ STR(808), /*""*/ STR(0)) + /*".json"*/ STR(697));
			self->texture_map = null_;
			if (is_real(DsMap(map).Value(/*"textures"*/ STR(812))))
			{
				self->texture_map = ds_map_create();
				if (ds_map_find_value((IntType)(DsMap(typemap).Value(map)), /*"textures"*/ STR(812)) == e_json_type_ARRAY && ds_list_valid(DsMap(map).Value(/*"textures"*/ STR(812))))
				{
					for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(map).Value(/*"textures"*/ STR(812)))); i++)
					{
						StringType texname = ds_list_find_value((IntType)(DsMap(map).Value(/*"textures"*/ STR(812))), i);
						texname = string_replace(texname, /*"minecraft:"*/ STR(808), /*""*/ STR(0));
						DsMap(self->texture_map)[string(i)] = block_load_model_file_texture(self, texname, res);
					}
				}
				else
					if (ds_map_valid(DsMap(map).Value(/*"textures"*/ STR(812))))
					{
						VarType key = ds_map_find_first((IntType)(DsMap(map).Value(/*"textures"*/ STR(812))));
						while (!is_undefined(key))
						{
							StringType texname = ds_map_find_value((IntType)(DsMap(map).Value(/*"textures"*/ STR(812))), key);
							texname = string_replace(texname, /*"minecraft:"*/ STR(808), /*""*/ STR(0));
							DsMap(self->texture_map)[key] = block_load_model_file_texture(self, texname, res);
							key = ds_map_find_next((IntType)(DsMap(map).Value(/*"textures"*/ STR(812))), key);
						}
						
					}
				
			}
			self->element_amount = IntType(0);
			VarType elementslist = DsMap(map).Value(/*"elements"*/ STR(813));
			if (!is_undefined(elementslist))
			{
				BoolType sortsize;
				IntType sizelist;
				if (ds_list_size((IntType)(elementslist)) > IntType(0))
				{
					sortsize = true;
					sizelist = ds_list_create();
				}
				else
				{
					sortsize = false;
					sizelist = null_;
				}
				
				for (IntType i = IntType(0); i < ds_list_size((IntType)(elementslist)); i++)
				{
					withOne (obj_block_load_element, (new obj_block_load_element)->id, self->id)
					{
						VarType elementmap = DsList(elementslist).Value(i);
						self->from = value_get_point3D(DsMap(elementmap).Value(/*"from"*/ STR(814)));
						self->to = value_get_point3D(DsMap(elementmap).Value(/*"to"*/ STR(815)));
						self->size = point3D_sub(self->to, self->from);
						self->volume = self->size.Value(X_) * self->size.Value(Y_) * self->size.Value(Z_);
						VarType rotationmap = DsMap(elementmap).Value(/*"rotation"*/ STR(816));
						if (ds_map_valid(rotationmap))
						{
							VarType origin, angle;
							VecType rot, scale;
							origin = value_get_point3D(DsMap(rotationmap).Value(/*"origin"*/ STR(817)), point3D(IntType(8), IntType(8), IntType(8)));
							angle = IntType(0);
							rot = vec3(IntType(0));
							scale = vec3(IntType(1));
							if (is_real(DsMap(rotationmap).Value(/*"angle"*/ STR(818))))
								angle = snap(clamp(DsMap(rotationmap).Value(/*"angle"*/ STR(818)), -IntType(45), IntType(45)), 22.5);
							if (is_bool(DsMap(rotationmap).Value(/*"rescale"*/ STR(819))) && DsMap(rotationmap).Value(/*"rescale"*/ STR(819)) > 0)
								scale = vec3(1.0 / dcos(abs(angle)));
							if (is_string(DsMap(rotationmap).Value(/*"axis"*/ STR(802))))
							{
								switch (StringType(DsMap(rotationmap).Value(/*"axis"*/ STR(802))).id)
								{
									case 820: // x
									{
										rot.Real(X_) = angle;
										scale.Real(X_) = IntType(1);
										break;
									}
									case 821: // z
									{
										rot.Real(Y_) = angle;
										scale.Real(Y_) = IntType(1);
										break;
									}
									case 803: // y
									{
										rot.Real(Z_) = angle;
										scale.Real(Z_) = IntType(1);
										break;
									}
								}
								
							}
							self->matrix = matrix_create(point3D_mul(origin, -IntType(1)), vec3(IntType(0)), vec3(IntType(1)));
							self->matrix = matrix_multiply(self->matrix, matrix_create(point3D(IntType(0), IntType(0), IntType(0)), vec3(IntType(0)), scale));
							self->matrix = matrix_multiply(self->matrix, matrix_create(origin, rot, vec3(IntType(1))));
							self->rotated = true;
						}
						else
							self->rotated = false;
						
						VarType facesmap = DsMap(elementmap).Value(/*"faces"*/ STR(822));
						for (IntType f = IntType(0); f < e_dir_amount; f++)
						{
							VarType curmap = DsMap(facesmap).Value(dir_get_string(f));
							if (!is_undefined(curmap))
							{
								self->face_render[f] = true;
								self->face_has_uv[f] = false;
								if (ds_list_valid(DsMap(curmap).Value(/*"uv"*/ STR(823))))
								{
									VarType uvlist = DsMap(curmap).Value(/*"uv"*/ STR(823));
									self->face_uv_from[f] = point2D(DsList(uvlist).Value(IntType(0)), DsList(uvlist).Value(IntType(1)));
									self->face_uv_to[f] = point2D(DsList(uvlist).Value(IntType(2)), DsList(uvlist).Value(IntType(3)));
									self->face_has_uv[f] = true;
									VecType uvfrom, uvto;
									uvfrom = self->face_uv_from.Value(f);
									uvto = self->face_uv_to.Value(f);
									self->face_uv_from[f] = vec2(mod_fix(uvfrom.Real(X_), block_size_ + 0.1), mod_fix(uvfrom.Real(Y_), block_size_ + 0.1));
									self->face_uv_to[f] = vec2(mod_fix(uvto.Real(X_), block_size_ + 0.1), mod_fix(uvto.Real(Y_), block_size_ + 0.1));
								}
								self->face_texture[f] = DsMap(curmap).Value(/*"texture"*/ STR(544));
								self->face_rotation[f] = IntType(0);
								if (is_real(DsMap(curmap).Value(/*"rotation"*/ STR(816))))
									self->face_rotation[f] = DsMap(curmap).Value(/*"rotation"*/ STR(816));
							}
							else
								self->face_render[f] = false;
							
						}
						if (sortsize)
						{
							IntType pos;
							for (pos = IntType(0); pos < ds_list_size(sizelist); pos++)
								if (idReal(DsList(sizelist).Value(pos), volume) > self->volume)
									break;
							ds_list_insert(sizelist, pos, self->id);
							ObjType(obj_block_load_model_file, self.otherId)->element_amount++;
						}
						else
						{
							ObjType(obj_block_load_model_file, self.otherId)->element[ObjType(obj_block_load_model_file, self.otherId)->element_amount++] = self->id;
						}
						
					}
					
				}
				if (sortsize)
				{
					self->element = ds_list_create_array(sizelist);
					ds_list_destroy(sizelist);
				}
			}
			if (res == null_)
				DsMap(global::load_assets_model_file_map)[filename_name(fname)] = self->id;
			ds_map_destroy(map);
			return self->id;
		}
		
		return VarType();
	}
	
	void block_load_model_file_event_destroy(Scope<obj_block_load_model_file> self)
	{
		if (self->texture_map != null_)
			ds_map_destroy(self->texture_map);
		for (IntType e = IntType(0); e < self->element_amount; e++)
			withOne (Object, self->element.Value(e), self->id)
				instance_destroy(self);
		
	}
	
	VarType block_load_model_file_texture(Scope<obj_block_load_model_file> self, VarType name, IntType res)
	{
		StringType fn;
		name = string_lower(name);
		if (string_pos(/*"assets/minecraft_"*/ STR(824), name) == IntType(1))
			name = string_replace(name, /*"assets/minecraft_"*/ STR(824), /*"block/"*/ STR(791));
		if (res == null_)
			return name;
		if (string_pos(/*"blocks/"*/ STR(825), name) == IntType(1))
		{
			name = string_replace(name, /*"blocks/"*/ STR(825), /*"block/"*/ STR(791));
			VarType newname = ds_map_find_key(global::legacy_block_texture_name_map, name);
			name = (newname == VarType() ? name : newname);
		}
		fn = global::load_folder + /*"/"*/ STR(20) + ObjType(obj_block_load_model_file, self->id)->name + /*"/"*/ STR(20) + name + /*".png"*/ STR(10);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/"*/ STR(20) + name + /*".png"*/ STR(10);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/"*/ STR(20) + string_replace(name, /*"blocks/"*/ STR(825), /*""*/ STR(0)) + /*".png"*/ STR(10);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/"*/ STR(20) + string_replace(name, /*"block/"*/ STR(791), /*""*/ STR(0)) + /*".png"*/ STR(10);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/"*/ STR(20) + filename_name(name) + /*".png"*/ STR(10);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/../../textures/"*/ STR(826) + name + /*".png"*/ STR(10);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/../../textures/item/"*/ STR(827) + name + /*".png"*/ STR(10);
		if (!file_exists_lib(fn))
			fn = global::load_folder + /*"/../../textures/block/"*/ STR(828) + name + /*".png"*/ STR(10);
		if (!file_exists_lib(fn))
			return name;
		if (ObjType(obj_resource, res)->model_texture_map == null_)
			ObjType(obj_resource, res)->model_texture_map = ds_map_create();
		else
			if (!is_undefined(DsMap(ObjType(obj_resource, res)->model_texture_map).Value(name)))
				return name;
		
		DsMap(ObjType(obj_resource, res)->model_texture_map)[name] = texture_create_square(fn);
		return name;
	}
	
	IntType block_load_render_model(ScopeAny self, VarType model, VecType rot, VarType uvlock, BoolType opaque, VarType wei, IntType res)
	{
		MatrixType rotmat;
		IntType modelstate;
		VarType colY, alphaY, colZ, alphaZ;
		if (res == null_)
		{
			modelstate = sInt(model_state_obj);
			colY = ObjType(obj_block_load_state_file, modelstate)->model_preview_color_yp;
			alphaY = ObjType(obj_block_load_state_file, modelstate)->model_preview_alpha_yp;
			colZ = ObjType(obj_block_load_state_file, modelstate)->model_preview_color_zp;
			alphaZ = ObjType(obj_block_load_state_file, modelstate)->model_preview_alpha_zp;
		}
		else
		{
			modelstate = null_;
			colY = null_;
			alphaY = null_;
			colZ = null_;
			alphaZ = null_;
		}
		
		if (rot.Real(X_) > IntType(0) || rot.Real(Z_) > IntType(0))
		{
			rotmat = matrix_create(point3D(-block_size_ / 2.0, -block_size_ / 2.0, -block_size_ / 2.0), vec3(IntType(0)), vec3(IntType(1)));
			rotmat = matrix_multiply(rotmat, matrix_create(point3D(block_size_ / 2.0, block_size_ / 2.0, block_size_ / 2.0), vec3(-rot.Real(X_), IntType(0), -rot.Real(Z_)), vec3(IntType(1))));
		}
		else
			rotmat = MAT_IDENTITY;
		
		withOne (obj_block_render_model, (new obj_block_render_model)->id, self->id)
		{
			self->rendermodel_id = array_length(VarType::CreateRef(global::block_rendermodels));
			array_add(VarType::CreateRef(global::block_rendermodels), self->id);
			VarType elementmodel;
			IntType texturemap;
			elementmodel = null_;
			texturemap = ds_map_create();
			while (model != null_)
			{
				if (idInt(model, texture_map) != null_)
					ds_map_merge(texturemap, idInt(model, texture_map), false);
				if (elementmodel == null_ && idInt(model, element_amount) > IntType(0))
					elementmodel = model;
				model = idVar(model, parent);
			}
			
			self->emissive = IntType(0);
			self->random_offset = IntType(0);
			self->random_offset_xy = IntType(0);
			self->offset_x = IntType(0);
			self->offset_y = IntType(0);
			self->offset_z = IntType(0);
			self->weight = wei;
			for (IntType f = IntType(0); f < e_dir_amount; f++)
			{
				self->face_full[f] = false;
				self->face_min[f] = null_;
				self->face_max[f] = null_;
				self->face_min_depth[f] = null_;
			}
			self->preview_color_zp = null_;
			self->preview_alpha_zp = IntType(0);
			self->preview_color_yp = null_;
			self->preview_alpha_yp = IntType(0);
			self->preview_tint = /*""*/ STR(0);
			self->element_amount = IntType(0);
			if (elementmodel != null_)
			{
				for (IntType e = IntType(0); e < idInt(elementmodel, element_amount); e++)
				{
					VarType elem = idArr(elementmodel, element).Value(e);
					withOne (obj_block_render_element, (new obj_block_render_element)->id, self->id)
					{
						self->from = idVar(elem, from);
						self->to = idVar(elem, to);
						ArrType facenewdir, faceuvrot;
						for (IntType f = IntType(0); f < e_dir_amount; f++)
						{
							facenewdir[f] = f;
							faceuvrot[f] = IntType(0);
						}
						self->rotated = idBool(elem, rotated);
						if (self->rotated)
							self->matrix = matrix_multiply(idVar(elem, matrix), rotmat);
						else
							if (rot.Real(X_) > IntType(0) || rot.Real(Z_) > IntType(0))
							{
								self->from = point3D_mul_matrix(idVar(elem, from), rotmat);
								self->to = point3D_mul_matrix(idVar(elem, to), rotmat);
								for (IntType a = X_; a <= Z_; a++)
								{
									RealType mi = min({ self->from.Value(a), self->to.Value(a) });
									RealType ma = max({ self->from.Value(a), self->to.Value(a) });
									self->from[a] = snap(mi, 0.01);
									self->to[a] = snap(ma, 0.01);
								}
								for (IntType _it = 0, _it_max = rot.Real(Z_) / 90.0; _it < _it_max; _it++)
								{
									IntType eastrotdir = facenewdir.Value(e_dir_EAST);
									facenewdir[e_dir_EAST] = facenewdir.Value(e_dir_SOUTH);
									facenewdir[e_dir_SOUTH] = facenewdir.Value(e_dir_WEST);
									facenewdir[e_dir_WEST] = facenewdir.Value(e_dir_NORTH);
									facenewdir[e_dir_NORTH] = eastrotdir;
								}
								for (IntType _it = 0, _it_max = rot.Real(X_) / 90.0; _it < _it_max; _it++)
								{
									IntType uprotdir = facenewdir.Value(e_dir_UP);
									facenewdir[e_dir_UP] = facenewdir.Value(e_dir_NORTH);
									facenewdir[e_dir_NORTH] = facenewdir.Value(e_dir_DOWN);
									facenewdir[e_dir_DOWN] = facenewdir.Value(e_dir_SOUTH);
									facenewdir[e_dir_SOUTH] = uprotdir;
								}
								switch ((IntType)rot.Real(X_))
								{
									case IntType(0):
									{
										faceuvrot[e_dir_UP] = rot.Real(Z_);
										faceuvrot[e_dir_DOWN] = -rot.Real(Z_);
										break;
									}
									
									case IntType(90):
									{
										faceuvrot[facenewdir.Value(e_dir_EAST)] = IntType(90);
										faceuvrot[facenewdir.Value(e_dir_WEST)] = -IntType(90);
										faceuvrot[facenewdir.Value(e_dir_UP)] = IntType(180);
										faceuvrot[e_dir_UP] = rot.Real(Z_);
										faceuvrot[e_dir_DOWN] = IntType(180) - rot.Real(Z_);
										break;
									}
									
									case IntType(180):
									{
										faceuvrot[e_dir_EAST] = IntType(180);
										faceuvrot[e_dir_WEST] = IntType(180);
										faceuvrot[e_dir_SOUTH] = IntType(180);
										faceuvrot[e_dir_NORTH] = IntType(180);
										faceuvrot[e_dir_UP] = rot.Real(Z_);
										faceuvrot[e_dir_DOWN] = -rot.Real(Z_);
										break;
									}
									
									case IntType(270):
									{
										faceuvrot[facenewdir.Value(e_dir_EAST)] = -IntType(90);
										faceuvrot[facenewdir.Value(e_dir_WEST)] = IntType(90);
										faceuvrot[facenewdir.Value(e_dir_DOWN)] = IntType(180);
										faceuvrot[e_dir_UP] = IntType(180) + rot.Real(Z_);
										faceuvrot[e_dir_DOWN] = -rot.Real(Z_);
										break;
									}
									
								}
								
							}
						
						for (IntType f = IntType(0); f < e_dir_amount; f++)
						{
							IntType nd = facenewdir.Value(f);
							self->face_render[nd] = idArr(elem, face_render).Value(f);
							if (!self->face_render.Value(nd))
								continue;
							VarType facerot = idArr(elem, face_rotation).Value(f);
							if (!(uvlock > 0))
								facerot += mod_fix(faceuvrot.Value(nd), IntType(360));
							if (idArr(elem, face_has_uv).Value(f))
							{
								VarType uvfrom, uvto;
								if (uvlock > 0 && faceuvrot.Value(nd) != IntType(0))
								{
									uvfrom = uv_rotate(idArr(elem, face_uv_from).Value(f), -faceuvrot.Value(nd), point2D(block_size_ / 2.0, block_size_ / 2.0));
									uvto = uv_rotate(idArr(elem, face_uv_to).Value(f), -faceuvrot.Value(nd), point2D(block_size_ / 2.0, block_size_ / 2.0));
									for (IntType a = X_; a <= Y_; a++)
									{
										RealType mi = min({ uvfrom.Value(a), uvto.Value(a) });
										RealType ma = max({ uvfrom.Value(a), uvto.Value(a) });
										uvfrom[a] = snap(mi, 0.01);
										uvto[a] = snap(ma, 0.01);
									}
								}
								else
								{
									uvfrom = idArr(elem, face_uv_from).Value(f);
									uvto = idArr(elem, face_uv_to).Value(f);
								}
								
								self->face_uv[nd][IntType(0)] = uvfrom;
								self->face_uv[nd][IntType(1)] = point2D(uvto.Value(X_), uvfrom.Value(Y_));
								self->face_uv[nd][IntType(2)] = uvto;
								self->face_uv[nd][IntType(3)] = point2D(uvfrom.Value(X_), uvto.Value(Y_));
								for (IntType _it = 0, _it_max = (RealType)facerot / 90.0; _it < _it_max; _it++)
								{
									VarType tmp = self->face_uv[nd][IntType(0)];
									self->face_uv[nd][IntType(0)] = self->face_uv[nd][IntType(3)];
									self->face_uv[nd][IntType(3)] = self->face_uv[nd][IntType(2)];
									self->face_uv[nd][IntType(2)] = self->face_uv[nd][IntType(1)];
									self->face_uv[nd][IntType(1)] = tmp;
								}
							}
							else
							{
								switch ((IntType)nd)
								{
									case e_dir_EAST:
									{
										self->face_uv[nd][IntType(0)] = point2D(block_size_ - self->to.Value(Y_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(1)] = point2D(block_size_ - self->from.Value(Y_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(2)] = point2D(block_size_ - self->from.Value(Y_), block_size_ - self->from.Value(Z_));
										self->face_uv[nd][IntType(3)] = point2D(block_size_ - self->to.Value(Y_), block_size_ - self->from.Value(Z_));
										break;
									}
									case e_dir_WEST:
									{
										self->face_uv[nd][IntType(0)] = point2D(self->from.Value(Y_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(1)] = point2D(self->to.Value(Y_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(2)] = point2D(self->to.Value(Y_), block_size_ - self->from.Value(Z_));
										self->face_uv[nd][IntType(3)] = point2D(self->from.Value(Y_), block_size_ - self->from.Value(Z_));
										break;
									}
									case e_dir_SOUTH:
									{
										self->face_uv[nd][IntType(0)] = point2D(self->from.Value(X_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(1)] = point2D(self->to.Value(X_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(2)] = point2D(self->to.Value(X_), block_size_ - self->from.Value(Z_));
										self->face_uv[nd][IntType(3)] = point2D(self->from.Value(X_), block_size_ - self->from.Value(Z_));
										break;
									}
									case e_dir_NORTH:
									{
										self->face_uv[nd][IntType(0)] = point2D(block_size_ - self->to.Value(X_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(1)] = point2D(block_size_ - self->from.Value(X_), block_size_ - self->to.Value(Z_));
										self->face_uv[nd][IntType(2)] = point2D(block_size_ - self->from.Value(X_), block_size_ - self->from.Value(Z_));
										self->face_uv[nd][IntType(3)] = point2D(block_size_ - self->to.Value(X_), block_size_ - self->from.Value(Z_));
										break;
									}
									case e_dir_UP:
									{
										self->face_uv[nd][IntType(0)] = point2D(self->from.Value(X_), self->from.Value(Y_));
										self->face_uv[nd][IntType(1)] = point2D(self->to.Value(X_), self->from.Value(Y_));
										self->face_uv[nd][IntType(2)] = point2D(self->to.Value(X_), self->to.Value(Y_));
										self->face_uv[nd][IntType(3)] = point2D(self->from.Value(X_), self->to.Value(Y_));
										break;
									}
									case e_dir_DOWN:
									{
										self->face_uv[nd][IntType(0)] = point2D(self->from.Value(X_), block_size_ - self->to.Value(Y_));
										self->face_uv[nd][IntType(1)] = point2D(self->to.Value(X_), block_size_ - self->to.Value(Y_));
										self->face_uv[nd][IntType(2)] = point2D(self->to.Value(X_), block_size_ - self->from.Value(Y_));
										self->face_uv[nd][IntType(3)] = point2D(self->from.Value(X_), block_size_ - self->from.Value(Y_));
										break;
									}
								}
								
								if (facerot > IntType(0))
								{
									self->face_uv[nd][IntType(0)] = uv_rotate(self->face_uv[nd][IntType(0)], facerot, point2D(block_size_ / 2.0, block_size_ / 2.0));
									self->face_uv[nd][IntType(1)] = uv_rotate(self->face_uv[nd][IntType(1)], facerot, point2D(block_size_ / 2.0, block_size_ / 2.0));
									self->face_uv[nd][IntType(2)] = uv_rotate(self->face_uv[nd][IntType(2)], facerot, point2D(block_size_ / 2.0, block_size_ / 2.0));
									self->face_uv[nd][IntType(3)] = uv_rotate(self->face_uv[nd][IntType(3)], facerot, point2D(block_size_ / 2.0, block_size_ / 2.0));
								}
							}
							
							for (IntType i = IntType(0); i < IntType(4); i++)
							{
								VarType fuv = self->face_uv[nd][i];
								fuv[X_] = min({ block_size_ - 1.0 / 256.0, fuv.Value(X_) });
								fuv[Y_] = min({ block_size_ - 1.0 / 256.0, fuv.Value(Y_) });
								self->face_uv[nd][i] = fuv;
							}
							VarType texname;
							VecType texpos, texsize;
							if (uvlock > 0 && idArr(elem, face_render).Value(nd))
								texname = idArr(elem, face_texture).Value(nd);
							else
								texname = idArr(elem, face_texture).Value(f);
							
							while (string_char_at(texname, IntType(1)) == /*"#"*/ STR(829))
							{
								texname = string_delete(texname, IntType(1), IntType(1));
								if (is_undefined(DsMap(texturemap).Value(texname)))
								{
									log({ /*"Could not find block texture"*/ STR(830), texname });
									texname = /*""*/ STR(0);
									break;
								}
								texname = DsMap(texturemap).Value(texname);
							}
							
							if (texname == /*""*/ STR(0))
							{
								self->face_render[nd] = false;
								continue;
							}
							self->face_texture_color[nd] = -IntType(1);
							if (res != null_ && ObjType(obj_resource, res)->model_texture_map != null_ && !is_undefined(DsMap(ObjType(obj_resource, res)->model_texture_map).Value(texname)))
							{
								self->face_depth[nd] = e_block_depth_DEPTH2;
								self->face_block_vbuffer[nd] = null_;
								self->face_vbuffer[nd] = DsMap(ObjType(obj_resource, res)->model_block_map).Value(texname);
								if (is_undefined(self->face_vbuffer.Value(nd)))
								{
									self->face_vbuffer[nd] = vbuffer_start();
									DsMap(ObjType(obj_resource, res)->model_block_map)[texname] = self->face_vbuffer.Value(nd);
								}
								texpos = vec2(IntType(0), IntType(0));
								texsize = vec2(block_size_, block_size_);
							}
							else
							{
								IntType slot;
								RealType sheetwidth, sheetheight;
								slot = -IntType(1);
								self->face_vbuffer[nd] = null_;
								if (opaque)
									slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_list), texname + /*" opaque"*/ STR(831));
								if (slot < IntType(0))
									slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_list), texname + /*" noalpha"*/ STR(832));
								if (slot < IntType(0))
									slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_list), texname);
								if (slot < IntType(0))
								{
									if (slot < IntType(0))
										slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_ani_list), texname);
									if (slot < IntType(0))
										slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_list), texname + /*" noalpha"*/ STR(832));
									if (slot < IntType(0))
										slot = ds_list_find_index((IntType)(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_ani_list), texname + /*" opaque"*/ STR(831));
									if (slot < IntType(0))
									{
										self->face_render[nd] = false;
										continue;
									}
									self->face_depth[nd] = DsList(ObjType(obj_resource, global::mc_res)->block_sheet_ani_depth_list).Value(slot);
									self->face_block_vbuffer[nd] = e_block_vbuffer_ANIMATED;
									VarType col = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_color_map).Value(texname);
									if (!is_undefined(col) && col == /*"water"*/ STR(787))
										self->face_block_vbuffer[nd] = e_block_vbuffer_WATER;
									sheetwidth = block_sheet_ani_width;
									sheetheight = block_sheet_ani_height;
								}
								else
								{
									self->face_depth[nd] = DsList(ObjType(obj_resource, global::mc_res)->block_sheet_depth_list).Value(slot);
									self->face_block_vbuffer[nd] = e_block_vbuffer_NORMAL;
									sheetwidth = block_sheet_width;
									sheetheight = block_sheet_height;
									VarType col = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_color_map).Value(texname);
									if (!is_undefined(col))
									{
										if (is_real(col))
											self->face_texture_color[nd] = col;
										else
										{
											switch (StringType(col).id)
											{
												case 833: // grass
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_GRASS;
													break;
												}
												case 834: // foliage
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_FOLIAGE;
													break;
												}
												case 835: // oak_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_OAK;
													break;
												}
												case 836: // spruce_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_SPRUCE;
													break;
												}
												case 837: // birch_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_BIRCH;
													break;
												}
												case 838: // jungle_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_JUNGLE;
													break;
												}
												case 839: // acacia_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_ACACIA;
													break;
												}
												case 840: // dark_oak_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_DARK_OAK;
													break;
												}
												case 841: // mangrove_leaves
												{
													self->face_block_vbuffer[nd] = e_block_vbuffer_LEAVES_MANGROVE;
													break;
												}
											}
											
										}
										
									}
								}
								
								texpos = point2D((mod(slot, sheetwidth)) * block_size_, ((IntType)(slot / sheetwidth)) * block_size_);
								texsize = vec2(sheetwidth * block_size_, sheetheight * block_size_);
								if (res == null_)
								{
									if ((nd == e_dir_UP && ObjType(obj_block_render_model, self.otherId)->preview_color_zp == null_ && alphaZ != IntType(0)) || (nd == e_dir_SOUTH && ObjType(obj_block_render_model, self.otherId)->preview_color_yp == null_ && alphaY != IntType(0)))
									{
										if (self->face_block_vbuffer.Value(nd) == e_block_vbuffer_ANIMATED || self->face_block_vbuffer.Value(nd) == e_block_vbuffer_WATER)
											global::buffer_current = global::load_assets_block_preview_ani_buffer;
										else
											global::buffer_current = global::load_assets_block_preview_buffer;
										
										RealType px, py;
										VarType alpha, col;
										px = mod(slot, sheetwidth);
										py = (IntType)(slot / sheetwidth);
										if ((nd == e_dir_UP && alphaZ == -IntType(1)) || (nd == e_dir_SOUTH && alphaY == -IntType(1)))
											alpha = buffer_read_alpha(px, py, sheetwidth);
										else
											alpha = (nd == e_dir_UP ? alphaZ : alphaY);
										
										if (alpha > IntType(0))
										{
											if ((nd == e_dir_UP && colZ == -IntType(1)) || (nd == e_dir_SOUTH && colY == -IntType(1)))
												col = buffer_read_color(px, py, sheetwidth);
											else
												col = (nd == e_dir_UP ? colZ : colY);
											
											if (self->face_texture_color.Value(nd) > -IntType(1))
												col = color_multiply(col, self->face_texture_color.Value(nd));
											else
											{
												VarType rescol;
												StringType colstr;
												rescol = null_;
												colstr = /*""*/ STR(0);
												switch ((IntType)self->face_block_vbuffer.Value(nd))
												{
													case e_block_vbuffer_GRASS:
													{
														colstr = /*"grass"*/ STR(833);
														break;
													}
													case e_block_vbuffer_FOLIAGE:
													{
														colstr = /*"foliage"*/ STR(834);
														break;
													}
													case e_block_vbuffer_WATER:
													{
														colstr = /*"water"*/ STR(787);
														break;
													}
													case e_block_vbuffer_LEAVES_OAK:
													{
														colstr = /*"foliage"*/ STR(834);
														break;
													}
													case e_block_vbuffer_LEAVES_SPRUCE:
													{
														rescol = ObjType(obj_resource, global::mc_res)->color_leaves_spruce;
														break;
													}
													case e_block_vbuffer_LEAVES_BIRCH:
													{
														rescol = ObjType(obj_resource, global::mc_res)->color_leaves_birch;
														break;
													}
													case e_block_vbuffer_LEAVES_JUNGLE:
													{
														colstr = /*"foliage"*/ STR(834);
														break;
													}
													case e_block_vbuffer_LEAVES_ACACIA:
													{
														colstr = /*"foliage"*/ STR(834);
														break;
													}
													case e_block_vbuffer_LEAVES_DARK_OAK:
													{
														colstr = /*"foliage"*/ STR(834);
														break;
													}
													case e_block_vbuffer_LEAVES_MANGROVE:
													{
														colstr = /*"foliage"*/ STR(834);
														break;
													}
												}
												
												if (rescol != null_)
													col = color_multiply(rescol, col);
												ObjType(obj_block_render_model, self.otherId)->preview_tint = colstr;
											}
											
											if (nd == e_dir_UP)
											{
												ObjType(obj_block_render_model, self.otherId)->preview_color_zp = col;
												ObjType(obj_block_render_model, self.otherId)->preview_alpha_zp = alpha;
											}
											else
											{
												ObjType(obj_block_render_model, self.otherId)->preview_color_yp = col;
												ObjType(obj_block_render_model, self.otherId)->preview_alpha_yp = alpha;
											}
											
										}
									}
								}
							}
							
							for (IntType t = IntType(0); t < IntType(4); t++)
								self->face_uv[nd][t] = vec2_div(point2D_add(self->face_uv[nd][t], texpos), texsize);
							self->face_edge[nd] = false;
							if (!self->rotated)
							{
								switch ((IntType)nd)
								{
									case e_dir_EAST:
									case e_dir_WEST:
									{
										if (nd == e_dir_EAST)
											self->face_edge[nd] = (self->to.Value(X_) == block_size_);
										else
											self->face_edge[nd] = (self->from.Value(X_) == IntType(0));
										
										if (self->face_edge.Value(nd) && !ObjType(obj_block_render_model, self.otherId)->face_full.Value(nd))
										{
											if (self->from.Value(Y_) == IntType(0) && self->to.Value(Y_) == block_size_)
											{
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == null_ || self->from.Value(Z_) <= ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_min[nd] = self->from.Value(Z_);
												if (ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == null_ || self->to.Value(Z_) >= ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_max[nd] = self->to.Value(Z_);
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == IntType(0) && ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == block_size_)
													ObjType(obj_block_render_model, self.otherId)->face_full[nd] = true;
											}
											if (ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd) == null_ || self->face_depth.Value(nd) < ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd))
												ObjType(obj_block_render_model, self.otherId)->face_min_depth[nd] = self->face_depth.Value(nd);
										}
										break;
									}
									
									case e_dir_SOUTH:
									case e_dir_NORTH:
									{
										if (nd == e_dir_SOUTH)
											self->face_edge[nd] = (self->to.Value(Y_) == block_size_);
										else
											self->face_edge[nd] = (self->from.Value(Y_) == IntType(0));
										
										if (self->face_edge.Value(nd) && !ObjType(obj_block_render_model, self.otherId)->face_full.Value(nd))
										{
											if (self->from.Value(X_) == IntType(0) && self->to.Value(X_) == block_size_)
											{
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == null_ || self->from.Value(Z_) <= ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_min[nd] = self->from.Value(Z_);
												if (ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == null_ || self->to.Value(Z_) >= ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_max[nd] = self->to.Value(Z_);
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == IntType(0) && ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == block_size_)
													ObjType(obj_block_render_model, self.otherId)->face_full[nd] = true;
											}
											if (ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd) == null_ || self->face_depth.Value(nd) < ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd))
												ObjType(obj_block_render_model, self.otherId)->face_min_depth[nd] = self->face_depth.Value(nd);
										}
										break;
									}
									
									case e_dir_UP:
									case e_dir_DOWN:
									{
										if (nd == e_dir_UP)
											self->face_edge[nd] = (self->to.Value(Z_) == block_size_);
										else
											self->face_edge[nd] = (self->from.Value(Z_) == IntType(0));
										
										if (self->face_edge.Value(nd) && !ObjType(obj_block_render_model, self.otherId)->face_full.Value(nd))
										{
											if (self->from.Value(X_) == IntType(0) && self->to.Value(X_) == block_size_)
											{
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == null_ || self->from.Value(Y_) <= ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_min[nd] = self->from.Value(Y_);
												if (ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == null_ || self->to.Value(Y_) >= ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd))
													ObjType(obj_block_render_model, self.otherId)->face_max[nd] = self->to.Value(Y_);
												if (ObjType(obj_block_render_model, self.otherId)->face_min.Value(nd) == IntType(0) && ObjType(obj_block_render_model, self.otherId)->face_max.Value(nd) == block_size_)
													ObjType(obj_block_render_model, self.otherId)->face_full[nd] = true;
											}
											if (ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd) == null_ || self->face_depth.Value(nd) < ObjType(obj_block_render_model, self.otherId)->face_min_depth.Value(nd))
												ObjType(obj_block_render_model, self.otherId)->face_min_depth[nd] = self->face_depth.Value(nd);
										}
										break;
									}
									
								}
								
							}
						}
						self->from_x = self->from.Value(X_);
						self->from_y = self->from.Value(Y_);
						self->from_z = self->from.Value(Z_);
						self->to_x = self->to.Value(X_);
						self->to_y = self->to.Value(Y_);
						self->to_z = self->to.Value(Z_);
						self->face_render_xp = self->face_render.Value(e_dir_EAST);
						self->face_render_xn = self->face_render.Value(e_dir_WEST);
						self->face_render_yp = self->face_render.Value(e_dir_SOUTH);
						self->face_render_yn = self->face_render.Value(e_dir_NORTH);
						self->face_render_zp = self->face_render.Value(e_dir_UP);
						self->face_render_zn = self->face_render.Value(e_dir_DOWN);
						if (self->face_render_xp > 0)
						{
							self->face_texture_color_xp = self->face_texture_color.Value(e_dir_EAST);
							self->face_depth_xp = self->face_depth.Value(e_dir_EAST);
							self->face_block_vbuffer_xp = self->face_block_vbuffer.Value(e_dir_EAST);
							self->face_vbuffer_xp = self->face_vbuffer.Value(e_dir_EAST);
							self->face_edge_xp = self->face_edge.Value(e_dir_EAST);
							self->face_uv_xp_0 = self->face_uv[e_dir_EAST][IntType(0)];
							self->face_uv_xp_0_x = self->face_uv_xp_0.Value(X_);
							self->face_uv_xp_0_y = self->face_uv_xp_0.Value(Y_);
							self->face_uv_xp_1 = self->face_uv[e_dir_EAST][IntType(1)];
							self->face_uv_xp_1_x = self->face_uv_xp_1.Value(X_);
							self->face_uv_xp_1_y = self->face_uv_xp_1.Value(Y_);
							self->face_uv_xp_2 = self->face_uv[e_dir_EAST][IntType(2)];
							self->face_uv_xp_2_x = self->face_uv_xp_2.Value(X_);
							self->face_uv_xp_2_y = self->face_uv_xp_2.Value(Y_);
							self->face_uv_xp_3 = self->face_uv[e_dir_EAST][IntType(3)];
							self->face_uv_xp_3_x = self->face_uv_xp_3.Value(X_);
							self->face_uv_xp_3_y = self->face_uv_xp_3.Value(Y_);
						}
						if (self->face_render_xn > 0)
						{
							self->face_texture_color_xn = self->face_texture_color.Value(e_dir_WEST);
							self->face_depth_xn = self->face_depth.Value(e_dir_WEST);
							self->face_block_vbuffer_xn = self->face_block_vbuffer.Value(e_dir_WEST);
							self->face_vbuffer_xn = self->face_vbuffer.Value(e_dir_WEST);
							self->face_edge_xn = self->face_edge.Value(e_dir_WEST);
							self->face_uv_xn_0 = self->face_uv[e_dir_WEST][IntType(0)];
							self->face_uv_xn_0_x = self->face_uv_xn_0.Value(X_);
							self->face_uv_xn_0_y = self->face_uv_xn_0.Value(Y_);
							self->face_uv_xn_1 = self->face_uv[e_dir_WEST][IntType(1)];
							self->face_uv_xn_1_x = self->face_uv_xn_1.Value(X_);
							self->face_uv_xn_1_y = self->face_uv_xn_1.Value(Y_);
							self->face_uv_xn_2 = self->face_uv[e_dir_WEST][IntType(2)];
							self->face_uv_xn_2_x = self->face_uv_xn_2.Value(X_);
							self->face_uv_xn_2_y = self->face_uv_xn_2.Value(Y_);
							self->face_uv_xn_3 = self->face_uv[e_dir_WEST][IntType(3)];
							self->face_uv_xn_3_x = self->face_uv_xn_3.Value(X_);
							self->face_uv_xn_3_y = self->face_uv_xn_3.Value(Y_);
						}
						if (self->face_render_yp > 0)
						{
							self->face_texture_color_yp = self->face_texture_color.Value(e_dir_SOUTH);
							self->face_depth_yp = self->face_depth.Value(e_dir_SOUTH);
							self->face_block_vbuffer_yp = self->face_block_vbuffer.Value(e_dir_SOUTH);
							self->face_vbuffer_yp = self->face_vbuffer.Value(e_dir_SOUTH);
							self->face_edge_yp = self->face_edge.Value(e_dir_SOUTH);
							self->face_uv_yp_0 = self->face_uv[e_dir_SOUTH][IntType(0)];
							self->face_uv_yp_0_x = self->face_uv_yp_0.Value(X_);
							self->face_uv_yp_0_y = self->face_uv_yp_0.Value(Y_);
							self->face_uv_yp_1 = self->face_uv[e_dir_SOUTH][IntType(1)];
							self->face_uv_yp_1_x = self->face_uv_yp_1.Value(X_);
							self->face_uv_yp_1_y = self->face_uv_yp_1.Value(Y_);
							self->face_uv_yp_2 = self->face_uv[e_dir_SOUTH][IntType(2)];
							self->face_uv_yp_2_x = self->face_uv_yp_2.Value(X_);
							self->face_uv_yp_2_y = self->face_uv_yp_2.Value(Y_);
							self->face_uv_yp_3 = self->face_uv[e_dir_SOUTH][IntType(3)];
							self->face_uv_yp_3_x = self->face_uv_yp_3.Value(X_);
							self->face_uv_yp_3_y = self->face_uv_yp_3.Value(Y_);
						}
						if (self->face_render_yn > 0)
						{
							self->face_texture_color_yn = self->face_texture_color.Value(e_dir_NORTH);
							self->face_depth_yn = self->face_depth.Value(e_dir_NORTH);
							self->face_block_vbuffer_yn = self->face_block_vbuffer.Value(e_dir_NORTH);
							self->face_vbuffer_yn = self->face_vbuffer.Value(e_dir_NORTH);
							self->face_edge_yn = self->face_edge.Value(e_dir_NORTH);
							self->face_uv_yn_0 = self->face_uv[e_dir_NORTH][IntType(0)];
							self->face_uv_yn_0_x = self->face_uv_yn_0.Value(X_);
							self->face_uv_yn_0_y = self->face_uv_yn_0.Value(Y_);
							self->face_uv_yn_1 = self->face_uv[e_dir_NORTH][IntType(1)];
							self->face_uv_yn_1_x = self->face_uv_yn_1.Value(X_);
							self->face_uv_yn_1_y = self->face_uv_yn_1.Value(Y_);
							self->face_uv_yn_2 = self->face_uv[e_dir_NORTH][IntType(2)];
							self->face_uv_yn_2_x = self->face_uv_yn_2.Value(X_);
							self->face_uv_yn_2_y = self->face_uv_yn_2.Value(Y_);
							self->face_uv_yn_3 = self->face_uv[e_dir_NORTH][IntType(3)];
							self->face_uv_yn_3_x = self->face_uv_yn_3.Value(X_);
							self->face_uv_yn_3_y = self->face_uv_yn_3.Value(Y_);
						}
						if (self->face_render_zp > 0)
						{
							self->face_texture_color_zp = self->face_texture_color.Value(e_dir_UP);
							self->face_depth_zp = self->face_depth.Value(e_dir_UP);
							self->face_block_vbuffer_zp = self->face_block_vbuffer.Value(e_dir_UP);
							self->face_vbuffer_zp = self->face_vbuffer.Value(e_dir_UP);
							self->face_edge_zp = self->face_edge.Value(e_dir_UP);
							self->face_uv_zp_0 = self->face_uv[e_dir_UP][IntType(0)];
							self->face_uv_zp_0_x = self->face_uv_zp_0.Value(X_);
							self->face_uv_zp_0_y = self->face_uv_zp_0.Value(Y_);
							self->face_uv_zp_1 = self->face_uv[e_dir_UP][IntType(1)];
							self->face_uv_zp_1_x = self->face_uv_zp_1.Value(X_);
							self->face_uv_zp_1_y = self->face_uv_zp_1.Value(Y_);
							self->face_uv_zp_2 = self->face_uv[e_dir_UP][IntType(2)];
							self->face_uv_zp_2_x = self->face_uv_zp_2.Value(X_);
							self->face_uv_zp_2_y = self->face_uv_zp_2.Value(Y_);
							self->face_uv_zp_3 = self->face_uv[e_dir_UP][IntType(3)];
							self->face_uv_zp_3_x = self->face_uv_zp_3.Value(X_);
							self->face_uv_zp_3_y = self->face_uv_zp_3.Value(Y_);
						}
						if (self->face_render_zn > 0)
						{
							self->face_texture_color_zn = self->face_texture_color.Value(e_dir_DOWN);
							self->face_depth_zn = self->face_depth.Value(e_dir_DOWN);
							self->face_block_vbuffer_zn = self->face_block_vbuffer.Value(e_dir_DOWN);
							self->face_vbuffer_zn = self->face_vbuffer.Value(e_dir_DOWN);
							self->face_edge_zn = self->face_edge.Value(e_dir_DOWN);
							self->face_uv_zn_0 = self->face_uv[e_dir_DOWN][IntType(0)];
							self->face_uv_zn_0_x = self->face_uv_zn_0.Value(X_);
							self->face_uv_zn_0_y = self->face_uv_zn_0.Value(Y_);
							self->face_uv_zn_1 = self->face_uv[e_dir_DOWN][IntType(1)];
							self->face_uv_zn_1_x = self->face_uv_zn_1.Value(X_);
							self->face_uv_zn_1_y = self->face_uv_zn_1.Value(Y_);
							self->face_uv_zn_2 = self->face_uv[e_dir_DOWN][IntType(2)];
							self->face_uv_zn_2_x = self->face_uv_zn_2.Value(X_);
							self->face_uv_zn_2_y = self->face_uv_zn_2.Value(Y_);
							self->face_uv_zn_3 = self->face_uv[e_dir_DOWN][IntType(3)];
							self->face_uv_zn_3_x = self->face_uv_zn_3.Value(X_);
							self->face_uv_zn_3_y = self->face_uv_zn_3.Value(Y_);
						}
						ObjType(obj_block_render_model, self.otherId)->element[ObjType(obj_block_render_model, self.otherId)->element_amount++] = self->id;
					}
					
				}
			}
			self->face_full_xp = self->face_full.Value(e_dir_EAST);
			self->face_min_xp = self->face_min.Value(e_dir_EAST);
			self->face_max_xp = self->face_max.Value(e_dir_EAST);
			self->face_min_depth_xp = self->face_min_depth.Value(e_dir_EAST);
			self->face_full_xn = self->face_full.Value(e_dir_WEST);
			self->face_min_xn = self->face_min.Value(e_dir_WEST);
			self->face_max_xn = self->face_max.Value(e_dir_WEST);
			self->face_min_depth_xn = self->face_min_depth.Value(e_dir_WEST);
			self->face_full_yp = self->face_full.Value(e_dir_SOUTH);
			self->face_min_yp = self->face_min.Value(e_dir_SOUTH);
			self->face_max_yp = self->face_max.Value(e_dir_SOUTH);
			self->face_min_depth_yp = self->face_min_depth.Value(e_dir_SOUTH);
			self->face_full_yn = self->face_full.Value(e_dir_NORTH);
			self->face_min_yn = self->face_min.Value(e_dir_NORTH);
			self->face_max_yn = self->face_max.Value(e_dir_NORTH);
			self->face_min_depth_yn = self->face_min_depth.Value(e_dir_NORTH);
			self->face_full_zp = self->face_full.Value(e_dir_UP);
			self->face_min_zp = self->face_min.Value(e_dir_UP);
			self->face_max_zp = self->face_max.Value(e_dir_UP);
			self->face_min_depth_zp = self->face_min_depth.Value(e_dir_UP);
			self->face_full_zn = self->face_full.Value(e_dir_DOWN);
			self->face_min_zn = self->face_min.Value(e_dir_DOWN);
			self->face_max_zn = self->face_max.Value(e_dir_DOWN);
			self->face_min_depth_zn = self->face_min_depth.Value(e_dir_DOWN);
			ds_map_destroy(texturemap);
			return self->id;
		}
		
		return IntType(0);
	}
	
}
