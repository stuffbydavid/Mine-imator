/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2023.06.12 16:04:04 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	void minecraft_assets_load_particles(VarType particlelist)
	{
		ArrType letterlist = ArrType::From({ /*"a"*/ STR(1727), /*"b"*/ STR(1728), /*"c"*/ STR(1729), /*"d"*/ STR(1730), /*"e"*/ STR(1205), /*"f"*/ STR(1206), /*"g"*/ STR(1731), /*"h"*/ STR(1732), /*"i"*/ STR(1733), /*"j"*/ STR(1734), /*"k"*/ STR(1735), /*"l"*/ STR(1736), /*"m"*/ STR(1737), /*"n"*/ STR(1207), /*"o"*/ STR(1738), /*"p"*/ STR(1739), /*"q"*/ STR(1740), /*"r"*/ STR(1741), /*"s"*/ STR(1742), /*"t"*/ STR(1208), /*"u"*/ STR(1209), /*"v"*/ STR(1743), /*"w"*/ STR(1744), /*"x"*/ STR(818), /*"y"*/ STR(801), /*"z"*/ STR(819) });
		for (IntType i = IntType(0); i < ds_list_size((IntType)(particlelist)); i++)
		{
			VarType tempmap;
			IntType ptemp;
			tempmap = DsList(particlelist).Value(i);
			ptemp = (new obj_particle_template)->id;
			ObjType(obj_particle_template, ptemp)->name = DsMap(tempmap).Value(/*"name"*/ STR(787));
			ObjType(obj_particle_template, ptemp)->texture_name = DsMap(tempmap).Value(/*"texture"*/ STR(532));
			if (!is_undefined(DsMap(tempmap).Value(/*"frames"*/ STR(1745))))
			{
				ObjType(obj_particle_template, ptemp)->frames = DsMap(tempmap).Value(/*"frames"*/ STR(1745));
				ObjType(obj_particle_template, ptemp)->animated = true;
			}
			else
			{
				ObjType(obj_particle_template, ptemp)->frames = IntType(1);
				ObjType(obj_particle_template, ptemp)->animated = false;
			}
			
			ObjType(obj_particle_template, ptemp)->size = value_get_real(DsMap(tempmap).Value(/*"size"*/ STR(978)), IntType(8));
			ObjType(obj_particle_template, ptemp)->letter_suffix = value_get_real(DsMap(tempmap).Value(/*"letter_suffix"*/ STR(1746)), false);
			ObjType(obj_particle_template, ptemp)->texture_list = ds_list_create();
			if (ObjType(obj_particle_template, ptemp)->animated)
			{
				for (IntType j = IntType(0); j < ObjType(obj_particle_template, ptemp)->frames; j++)
				{
					if (ObjType(obj_particle_template, ptemp)->letter_suffix > 0)
						ds_list_add({ ObjType(obj_particle_template, ptemp)->texture_list, ObjType(obj_particle_template, ptemp)->texture_name + /*"_"*/ STR(1100) + letterlist.Value(j) });
					else
						ds_list_add({ ObjType(obj_particle_template, ptemp)->texture_list, ObjType(obj_particle_template, ptemp)->texture_name + /*"_"*/ STR(1100) + string(j) });
					
				}
			}
			else
			{
				ds_list_add({ ObjType(obj_particle_template, ptemp)->texture_list, ObjType(obj_particle_template, ptemp)->texture_name });
			}
			
			ds_list_add({ global::particle_template_list, ptemp });
			ds_map_add(global::particle_template_map, ObjType(obj_particle_template, ptemp)->name, ptemp);
		}
	}
	
	BoolType minecraft_assets_load_startup(ScopeAny self)
	{
		global::mc_assets = (new obj_minecraft_assets)->id;
		global::mc_builder = (new obj_builder)->id;
		global::mc_res = (new obj_resource)->id;
		sStr(window_state) = /*"load_assets"*/ STR(79);
		global::load_assets_stage = /*"unzip"*/ STR(1267);
		global::load_assets_progress = IntType(0);
		global::load_assets_map = null_;
		global::load_assets_type_map = null_;
		global::load_assets_block_index = IntType(0);
		window_set_size(IntType(740), IntType(450));
		sArr(alarm)[IntType(0)] = IntType(1);
		global::pattern_update = ArrType();
		withOne (obj_resource, global::mc_res, self->id)
		{
			self->save_id = /*"default"*/ STR(98);
			self->type = e_res_type_PACK;
			self->display_name = /*"Minecraft"*/ STR(1747);
			self->font_minecraft = true;
			self->font = new_minecraft_font(self);
			self->font_preview = self->font;
			self->font_no_aa = self->font;
			self->material_format = e_material_FORMAT_NONE;
		}
		
		if (!minecraft_assets_load_startup_version())
		{
			log({ /*"Could not load "*/ STR(1748) + string(global::_app->setting_minecraft_assets_version) + /*" assets. Resetting to default"*/ STR(1749), minecraft_version });
			global::_app->setting_minecraft_assets_version = minecraft_version;
			if (!minecraft_assets_load_startup_version())
				return false;
		}
		global::load_assets_splash = null_;
		global::load_assets_credits = /*""*/ STR(0);
		if (file_exists_lib(splash_directory + /*"splashes.json"*/ STR(1750)))
		{
			IntType map;
			VarType splashlist, splash;
			StringType splashfile;
			map = json_load({ splash_directory + /*"splashes.json"*/ STR(1750) });
			splashlist = DsMap(map).Value(/*"splashes"*/ STR(1751));
			splash = DsList(splashlist).Value(irandom((IntType)(ds_list_size((IntType)(splashlist)) - IntType(1))));
			splashfile = splash_directory + DsMap(splash).Value(/*"file"*/ STR(115));
			if (file_exists_lib(splashfile))
			{
				global::load_assets_splash = sprite_add(splashfile, IntType(0), IntType(0), IntType(0), IntType(0), IntType(0));
				global::load_assets_credits = DsMap(splash).Value(/*"credits"*/ STR(1752));
			}
		}
		return true;
	}
	
	BoolType minecraft_assets_load_startup_version()
	{
		StringType version = global::_app->setting_minecraft_assets_version;
		log({ /*"Loading Minecraft assets version"*/ STR(1753), version });
		global::load_assets_file = minecraft_directory + version + /*".midata"*/ STR(96);
		global::load_assets_zip_file = minecraft_directory + version + /*".zip"*/ STR(5);
		if (!file_exists_lib(global::load_assets_file))
		{
			log({ /*"Could not find Minecraft assets file"*/ STR(1754), global::load_assets_file });
			return false;
		}
		if (!file_exists_lib(global::load_assets_zip_file))
		{
			log({ /*"Could not find Minecraft assets archive"*/ STR(1755), global::load_assets_zip_file });
			return false;
		}
		global::load_assets_type_map = ds_int_map_create();
		global::load_assets_map = json_load({ global::load_assets_file, global::load_assets_type_map });
		if (!ds_map_valid(global::load_assets_map))
		{
			log({ /*"Could not parse JSON"*/ STR(1756), global::load_assets_file });
			ds_map_destroy(global::load_assets_type_map);
			return false;
		}
		VarType format = DsMap(global::load_assets_map).Value(/*"format"*/ STR(88));
		if (!is_real(format))
			format = e_minecraft_assets_FORMAT_110_PRE_1;
		if (format != minecraft_assets_format)
		{
			log({ /*"Unsupported archive, format"*/ STR(1757), format });
			return false;
		}
		VarType patch = DsMap(global::load_assets_map).Value(/*"patch"*/ STR(1758));
		if (!is_real(patch))
			patch = IntType(1);
		global::load_assets_startup_dir = mc_file_directory + version + (patch > IntType(1) ? /*"_"*/ STR(1100) + string(patch) : /*""*/ STR(0)) + /*"/"*/ STR(16);
		global::load_assets_dir = global::load_assets_startup_dir;
		global::load_assets_state_file_map = ds_string_map_create();
		global::load_assets_model_file_map = ds_map_create();
		return true;
	}
	
	BoolType minecraft_assets_reload()
	{
		StringType fname = minecraft_directory + minecraft_version + /*".midata"*/ STR(96);
		log({ /*"Reloading models"*/ STR(1759) });
		IntType typemap, map;
		typemap = ds_int_map_create();
		map = json_load({ fname, typemap });
		if (!ds_map_valid(map))
		{
			log({ /*"Could not parse JSON"*/ STR(1756), fname });
			ds_map_destroy(typemap);
			return false;
		}
		global::load_assets_model_file_map = ds_map_create();
		withOne (obj_minecraft_assets, global::mc_assets, noone)
		{
			ds_map_clear(self->model_name_map);
			ds_list_clear(self->char_list);
			ds_list_clear(self->special_block_list);
			VarType characterslist = DsMap(map).Value(/*"characters"*/ STR(1694));
			if (is_undefined(characterslist))
			{
				log({ /*"No character list found"*/ STR(1695) });
				break;
			}
			for (IntType i = IntType(0); i < ds_list_size((IntType)(characterslist)); i++)
			{
				IntType model = model_load(DsList(characterslist).Value(i), global::load_assets_dir + mc_character_directory);
				if (!(model > 0))
				{
					log({ /*"Could not load model"*/ STR(1696) });
					continue;
				}
				DsMap(self->model_name_map)[ObjType(obj_model, model)->name] = model;
				ds_list_add({ self->char_list, model });
			}
			VarType specialblockslist = DsMap(map).Value(/*"special_blocks"*/ STR(1698));
			if (is_undefined(specialblockslist))
			{
				log({ /*"No special block list found"*/ STR(1699) });
				break;
			}
			for (IntType i = IntType(0); i < ds_list_size((IntType)(specialblockslist)); i++)
			{
				IntType model = model_load(DsList(specialblockslist).Value(i), global::load_assets_dir + mc_special_block_directory);
				if (!(model > 0))
				{
					log({ /*"Could not load model"*/ STR(1696) });
					continue;
				}
				DsMap(self->model_name_map)[ObjType(obj_model, model)->name] = model;
				ds_list_add({ self->special_block_list, model });
			}
			VarType key = ds_map_find_first(global::load_assets_model_file_map);
			while (!is_undefined(key))
			{
				withOne (obj_block_load_model_file, DsMap(global::load_assets_model_file_map).Value(key), self->id)
					instance_destroy(ScopeAny(self));
				
				key = ds_map_find_next(global::load_assets_model_file_map, key);
			}
			
		}
		
		ds_map_destroy(global::load_assets_model_file_map);
		ds_map_destroy(map);
		ds_map_destroy(typemap);
		withAll (obj_template, noone)
			if (self->type == e_temp_type_CHARACTER || self->type == e_temp_type_SPECIAL_BLOCK)
				temp_update_model(ScopeAny(self));
		
		withAll (obj_timeline, noone)
			tl_update_scenery_part(ScopeAny(self));
		
		return false;
	}
	
	BoolType minecraft_assets_startup(ScopeAny self)
	{
		global::block_rendermodels = ArrType();
		global::block_objs = ArrType();
		global::player_head_vbuffer = null_;
		global::block_rendermodels[IntType(0)] = null_;
		global::block_objs[IntType(0)] = null_;
		if (sVar(setting_minecraft_assets_new_version) != /*""*/ STR(0))
		{
			sStr(new_assets_version) = sVar(setting_minecraft_assets_new_version).Str();
			sVar(new_assets_format) = sVar(setting_minecraft_assets_new_format);
			sVar(new_assets_changes) = sVar(setting_minecraft_assets_new_changes);
			sArr(new_assets_changes_lines) = string_split(sVar(new_assets_changes), /*"\n"*/ STR(938));
			sVar(new_assets_image) = sStr(setting_minecraft_assets_new_image);
			sInt(new_assets_scroll) = (new obj_scrollbar)->id;
			if (sVar(new_assets_image) != /*""*/ STR(0) && file_exists_lib(sVar(new_assets_image)))
				sInt(new_assets_image_texture) = texture_create(sVar(new_assets_image));
			else
				sInt(new_assets_image_texture) = null_;
			
			sStr(window_state) = /*"new_assets"*/ STR(78);
			sStr(new_assets_stage) = /*""*/ STR(0);
			sReal(new_assets_download_progress) = IntType(0);
			window_set_size(IntType(540), IntType(480));
			window_set_caption(/*"Mine-imator"*/ STR(19));
			sArr(alarm)[IntType(0)] = IntType(1);
		}
		else
			if (!minecraft_assets_load_startup(self))
			{
				error(/*"errorloadassets"*/ STR(97));
				return false;
			}
		
		return true;
	}
	
	VarType minecraft_asset_get_name(StringType type, VarType name)
	{
		if (string_digits(name) == name)
			return name;
		if (!text_exists(type + name))
			return (dev_mode_debug_names ? /*"?????? ["*/ STR(1760) + name + /*"]"*/ STR(1203) : string_format_snakecase(name));
		else
			return text_get({ type + name }) + (dev_mode_debug_names ? /*" ["*/ STR(1761) + name + /*"]"*/ STR(1203) : /*""*/ STR(0));
		
		return VarType();
	}
	
	void minecraft_update_patterns()
	{
		if (global::pattern_update != null_ && global::_app->window_busy != /*"popup"*/ STR(1566) + ObjType(obj_popup, global::_app->popup_loading)->name)
		{
			VarType obj = global::pattern_update;
			if (is_array(global::pattern_update))
			{
				for (IntType i = IntType(0); i < array_length(VarType::CreateRef(global::pattern_update)); i++)
				{
					obj = global::pattern_update.Value(i);
					withOne (Object, obj, global::_app->id)
					{
						if (sprite_exists(sInt(pattern_skin)))
							sprite_delete(sInt(pattern_skin));
						VarType res;
						withOne (Object, obj, self->id)
							res = temp_get_model_texobj(self, null_);
						
						sInt(pattern_skin) = minecraft_update_pattern_generate(sVar(model_name), sVar(pattern_base_color), sVar(pattern_pattern_list), sVar(pattern_color_list), res);
						if (obj == global::temp_edit)
							ObjType(obj_preview, global::_app->lib_preview)->update = true;
					}
					
				}
			}
			else
			{
				withOne (Object, obj, global::_app->id)
				{
					if (sprite_exists(sInt(pattern_skin)))
						sprite_delete(sInt(pattern_skin));
					VarType res;
					withOne (Object, obj, self->id)
						res = temp_get_model_texobj(self, null_);
					
					sInt(pattern_skin) = minecraft_update_pattern_generate(sVar(model_name), sVar(pattern_base_color), sVar(pattern_pattern_list), sVar(pattern_color_list), res);
					if (obj == global::temp_edit)
						ObjType(obj_preview, global::_app->lib_preview)->update = true;
				}
				
			}
			
			global::pattern_update = ArrType();
		}
	}
	
	IntType minecraft_update_pattern_generate(VarType type, VarType color, VarType patternlist, VarType colorlist, VarType res)
	{
		RealType skinratio;
		ArrType maskarray;
		IntType patternskin;
		if (res == null_ || !res_is_ready(res))
			res = global::mc_res;
		StringType patternbase, patterndir;
		patternbase = (type == /*"banner"*/ STR(784) ? /*"entity/banner_base"*/ STR(1762) : /*"entity/shield_base"*/ STR(1763));
		patterndir = (type == /*"banner"*/ STR(784) ? /*"entity/banner/"*/ STR(1764) : /*"entity/shield/"*/ STR(1765));
		skinratio = IntType(1);
		maskarray = ArrType();
		if (idVar(res, type) == e_res_type_SKIN)
			return sprite_duplicate(idInt(res, model_texture));
		draw_set_color(c_white);
		draw_set_alpha(1.0);
		skinratio = max({ skinratio, ceil((RealType)sprite_get_width((IntType)(DsMap(idInt(res, model_texture_map)).Value(patternbase))) / sprite_get_width((IntType)(DsMap(ObjType(obj_resource, global::mc_res)->model_texture_map).Value(patternbase)))) });
		for (IntType i = IntType(0); i < ds_list_size(global::minecraft_pattern_list); i++)
		{
			VarType patternname = DsList(global::minecraft_pattern_list).Value(i);
			skinratio = max({ skinratio, ceil((RealType)sprite_get_width((IntType)(DsMap(idInt(res, model_texture_map)).Value(patterndir + patternname))) / sprite_get_width((IntType)(DsMap(ObjType(obj_resource, global::mc_res)->model_texture_map).Value(patterndir + patternname)))) });
		}
		global::shader_mask = (idVar(res, pack_format) < e_minecraft_pack_FORMAT_115);
		for (IntType i = IntType(0); i < ds_list_size(global::minecraft_pattern_list); i++)
		{
			VarType patternname = DsList(global::minecraft_pattern_list).Value(i);
			array_add(VarType::CreateRef(maskarray), texture_create_crop(DsMap(idInt(res, model_texture_map)).Value(patterndir + patternname), IntType(0), IntType(0), IntType(64) * skinratio, IntType(64) * skinratio));
		}
		global::shader_mask = false;
		IntType patternsurf = surface_create((IntType)(IntType(64) * skinratio), (IntType)(IntType(64) * skinratio));
		surface_set_target(patternsurf);
	{
		draw_clear_alpha(c_black, 0.0);
		draw_image({ DsMap(idInt(res, model_texture_map)).Value(patternbase), IntType(0), IntType(0), IntType(0) });
		draw_image({ maskarray.Value(IntType(0)), IntType(0), IntType(0), IntType(0), IntType(1), IntType(1), color, IntType(1) });
		for (IntType i = IntType(0); i < array_length(VarType::CreateRef(patternlist)); i++)
		{
			IntType pattern = ds_list_find_index(global::minecraft_pattern_list, patternlist.Value(i));
			draw_image({ maskarray.Value(pattern), IntType(0), IntType(0), IntType(0), IntType(1), IntType(1), colorlist.Value(i), IntType(1) });
		}
		gpu_set_blendmode_ext(bm_src_color, bm_one);
		draw_image({ maskarray.Value(IntType(0)), IntType(0), IntType(0), IntType(0), IntType(1), IntType(1), c_black, IntType(1) });
		gpu_set_blendmode(bm_normal);
	}
		surface_reset_target();
		patternskin = texture_surface(patternsurf);
		for (IntType i = IntType(0); i < array_length(VarType::CreateRef(maskarray)); i++)
			texture_free(maskarray.Value(i));
		surface_free(patternsurf);
		return patternskin;
	}
	
	BoolType missing_file(StringType fn)
	{
		log({ /*"Missing file"*/ STR(1766), fn });
		show_message(/*"The file "*/ STR(1767) + fn + /*" could not be found. If you are running from an archive, extract all the files and try again. If problems persist, re-install the program."*/ STR(1768));
		return false;
	}
	
	void model_file_event_destroy(Scope<obj_model_file> self)
	{
		if (self->part_list != null_)
		{
			for (IntType p = IntType(0); p < ds_list_size(self->part_list); p++)
				withOne (Object, DsList(self->part_list).Value(p), self->id)
					instance_destroy(self);
			
			ds_list_destroy(self->part_list);
		}
	}
	
	IntType model_file_load(StringType fname, IntType res)
	{
		if (!file_exists_lib(fname))
		{
			log({ /*"Could not find model file"*/ STR(807), fname });
			return null_;
		}
		IntType map = json_load({ fname });
		if (!ds_map_valid(map))
		{
			log({ /*"Could not parse model file"*/ STR(808), fname });
			return null_;
		}
		if (!is_string(DsMap(map).Value(/*"name"*/ STR(787))))
		{
			log({ /*"Missing parameter \"name\""*/ STR(788) });
			return null_;
		}
		if (!is_string(DsMap(map).Value(/*"texture"*/ STR(532))))
		{
			log({ /*"Missing parameter \"texture\""*/ STR(1769) });
			return null_;
		}
		if (!ds_list_valid(DsMap(map).Value(/*"texture_size"*/ STR(1770))))
		{
			log({ /*"Missing array \"texture_size\""*/ STR(1771) });
			return null_;
		}
		if (!ds_list_valid(DsMap(map).Value(/*"parts"*/ STR(1772))))
		{
			log({ /*"Missing array \"parts\""*/ STR(1773) });
			return null_;
		}
		withOne (obj_model_file, (new obj_model_file)->id, noone)
		{
			self->name = DsMap(map).Value(/*"name"*/ STR(787));
			if (res == null_ && dev_mode_debug_names && !text_exists(/*"model"*/ STR(515) + self->name))
				log({ /*"model/"*/ STR(1774) + self->name + dev_mode_name_translation_message });
			self->description = value_get_string(DsMap(map).Value(/*"description"*/ STR(1775)), /*""*/ STR(0));
			self->texture_name = DsMap(map).Value(/*"texture"*/ STR(532));
			self->texture_inherit = self->id;
			self->texture_material_inherit = self->id;
			self->texture_normal_inherit = self->id;
			if (res != null_)
				model_file_load_texture(self->texture_name, res);
			if (res != null_)
			{
				self->texture_material_name = value_get_string(DsMap(map).Value(/*"texture_material"*/ STR(1776)), /*""*/ STR(0));
				if (self->texture_material_name != /*""*/ STR(0))
					model_file_load_texture_material(self->texture_material_name, res);
				self->texture_normal_name = value_get_string(DsMap(map).Value(/*"texture_normal"*/ STR(1777)), /*""*/ STR(0));
				if (self->texture_normal_name != /*""*/ STR(0))
					model_file_load_tex_normal(self->texture_normal_name, res);
			}
			else
			{
				self->texture_material_name = self->texture_name;
				self->texture_normal_name = self->texture_name;
			}
			
			self->texture_size = value_get_point2D(DsMap(map).Value(/*"texture_size"*/ STR(1770)));
			RealType size = max({ self->texture_size.Value(X_), self->texture_size.Value(Y_) });
			self->texture_size = vec2(size, size);
			self->part_mixing_shapes = false;
			self->color_inherit = false;
			self->color_blend = c_white;
			self->color_alpha = IntType(1);
			self->color_emissive = IntType(0);
			self->color_mix = c_black;
			self->color_mix_percent = IntType(0);
			self->player_skin = value_get_real(DsMap(map).Value(/*"player_skin"*/ STR(1778)), false);
			self->scale = value_get_point3D(DsMap(map).Value(/*"scale"*/ STR(1779)), vec3(IntType(1), IntType(1), IntType(1)));
			self->bounds_parts_start = point3D(no_limit, no_limit, no_limit);
			self->bounds_parts_end = point3D(-no_limit, -no_limit, -no_limit);
			self->has_3d_plane = false;
			VarType partlist = DsMap(map).Value(/*"parts"*/ STR(1772));
			self->render_part_list = ds_list_create();
			self->file_part_list = ds_list_create();
			self->part_list = ds_list_create();
			for (IntType p = IntType(0); p < ds_list_size((IntType)(partlist)); p++)
			{
				VarType part = model_file_load_part(ScopeAny(self), DsList(partlist).Value(p), self->id, res, self->id);
				if (part == null_)
					return null_;
				if (part > IntType(0))
					ds_list_add({ self->part_list, part });
			}
			ds_map_destroy(map);
			return self->id;
		}
		
		return IntType(0);
	}
	
	VarType model_file_load_part(ScopeAny self, VarType map, IntType root, IntType res, IntType model)
	{
		if (!is_undefined(DsMap(map).Value(/*"visible"*/ STR(1780))) && !(DsMap(map).Value(/*"visible"*/ STR(1780)) > 0))
			return IntType(0);
		if (!is_string(DsMap(map).Value(/*"name"*/ STR(787))))
		{
			log({ /*"Missing parameter \"name\""*/ STR(788) });
			return null_;
		}
		if (!ds_list_valid(DsMap(map).Value(/*"position"*/ STR(40))))
		{
			log({ /*"Missing array \"position\""*/ STR(1781) });
			return null_;
		}
		for (IntType i = IntType(0); i < ds_list_size(ObjType(obj_model_file, root)->file_part_list); i++)
		{
			if (ObjType(obj_model_part, DsList(ObjType(obj_model_file, root)->file_part_list).Value(i))->name == DsMap(map).Value(/*"name"*/ STR(787)))
			{
				log({ /*"Duplicate part name found"*/ STR(1782), DsMap(map).Value(/*"name"*/ STR(787)) });
				return null_;
			}
		}
		withOne (obj_model_part, (new obj_model_part)->id, self->id)
		{
			self->name = DsMap(map).Value(/*"name"*/ STR(787));
			if (res == null_ && dev_mode_debug_names && !text_exists(/*"modelpart"*/ STR(748) + self->name))
				log({ /*"model/part/"*/ STR(1783) + self->name + dev_mode_name_translation_message });
			self->depth = value_get_real(DsMap(map).Value(/*"depth"*/ STR(611)), IntType(0));
			IntType pos;
			for (pos = IntType(0); pos < ds_list_size(ObjType(obj_model_file, model)->render_part_list); pos++)
				if (idVar(DsList(ObjType(obj_model_file, model)->render_part_list).Value(pos), depth) > self->depth)
					break;
			ds_list_insert(ObjType(obj_model_file, model)->render_part_list, pos, self->id);
			self->description = value_get_string(DsMap(map).Value(/*"description"*/ STR(1775)), /*""*/ STR(0));
			if (is_string(DsMap(map).Value(/*"texture"*/ STR(532))))
			{
				self->texture_name = DsMap(map).Value(/*"texture"*/ STR(532));
				self->texture_inherit = self->id;
				self->texture_material_inherit = self->id;
				self->texture_normal_inherit = self->id;
				if (!ds_list_valid(DsMap(map).Value(/*"texture_size"*/ STR(1770))))
				{
					log({ /*"Missing array \"texture_size\""*/ STR(1771) });
					return null_;
				}
				if (res != null_)
				{
					model_file_load_texture(self->texture_name, res);
					self->texture_material_name = value_get_string(DsMap(map).Value(/*"texture_material"*/ STR(1776)), /*""*/ STR(0));
					self->texture_normal_name = value_get_string(DsMap(map).Value(/*"texture_normal"*/ STR(1777)), /*""*/ STR(0));
					if (self->texture_material_name != /*""*/ STR(0))
						model_file_load_texture_material(self->texture_material_name, res);
					else
						self->texture_material_inherit = idInt(self.otherId, texture_material_inherit);
					
					if (self->texture_normal_name != /*""*/ STR(0))
						model_file_load_tex_normal(self->texture_normal_name, res);
					else
						self->texture_normal_inherit = idInt(self.otherId, texture_normal_inherit);
					
				}
				else
				{
					self->texture_material_name = self->texture_name;
					self->texture_normal_name = self->texture_name;
				}
				
				self->texture_size = value_get_point2D(DsMap(map).Value(/*"texture_size"*/ STR(1770)));
				RealType size = max({ self->texture_size.Value(X_), self->texture_size.Value(Y_) });
				self->texture_size = vec2(size, size);
			}
			else
			{
				self->texture_name = /*""*/ STR(0);
				self->texture_material_name = /*""*/ STR(0);
				self->texture_normal_name = /*""*/ STR(0);
				self->texture_inherit = idInt(self.otherId, texture_inherit);
				self->texture_material_inherit = idInt(self.otherId, texture_material_inherit);
				self->texture_normal_inherit = idInt(self.otherId, texture_normal_inherit);
				self->texture_size = idVar(self->texture_inherit, texture_size);
			}
			
			self->color_inherit = value_get_real(DsMap(map).Value(/*"color_inherit"*/ STR(1784)), true);
			self->color_blend = value_get_color(DsMap(map).Value(/*"color_blend"*/ STR(1785)), c_white);
			self->color_alpha = value_get_real(DsMap(map).Value(/*"color_alpha"*/ STR(1786)), IntType(1));
			if (is_real(/*"color_emissive"*/ STR(1787)))
				self->color_emissive = value_get_real(DsMap(map).Value(/*"color_emissive"*/ STR(1787)), IntType(0));
			else
				self->color_emissive = value_get_real(DsMap(map).Value(/*"color_brightness"*/ STR(1788)), IntType(0));
			
			self->color_mix = value_get_color(DsMap(map).Value(/*"color_mix"*/ STR(1789)), c_black);
			self->color_mix_percent = value_get_real(DsMap(map).Value(/*"color_mix_percent"*/ STR(1790)), IntType(0));
			self->part_mixing_shapes = false;
			if (self->color_inherit > 0)
			{
				self->color_blend = color_multiply(self->color_blend, idVar(self.otherId, color_blend));
				self->color_alpha *= idVar(self.otherId, color_alpha);
				self->color_emissive = clamp(self->color_emissive + idVar(self.otherId, color_emissive), IntType(0), IntType(1));
				self->color_mix = color_add(self->color_mix, idVar(self.otherId, color_mix));
				self->color_mix_percent = clamp(self->color_mix_percent + idVar(self.otherId, color_mix_percent), IntType(0), IntType(1));
			}
			if (self->color_mix_percent > IntType(0))
				self->part_mixing_shapes = true;
			self->position_noscale = value_get_point3D(DsMap(map).Value(/*"position"*/ STR(40)));
			self->position = point3D_mul(self->position_noscale, idVar(self.otherId, scale));
			self->rotation = value_get_point3D(DsMap(map).Value(/*"rotation"*/ STR(814)), vec3(IntType(0), IntType(0), IntType(0)));
			self->scale = value_get_point3D(DsMap(map).Value(/*"scale"*/ STR(1779)), vec3(IntType(1), IntType(1), IntType(1)));
			self->scale = vec3_mul(self->scale, idVar(self.otherId, scale));
			self->show_position = value_get_real(DsMap(map).Value(/*"show_position"*/ STR(1791)), false);
			if (Obj(self.otherId)->subAssetId == ID_obj_model_part && idVar(self.otherId, locked) > 0)
				self->locked = true;
			else
				self->locked = value_get_real(DsMap(map).Value(/*"locked"*/ STR(909)), false);
			
			self->lock_bend = true;
			if (Obj(self.otherId)->subAssetId == ID_obj_model_part && idInt(self.otherId, bend_part) != null_)
			{
				if (is_bool(DsMap(map).Value(/*"lock_bend"*/ STR(1792))) || is_real(DsMap(map).Value(/*"lock_bend"*/ STR(1792))))
					self->lock_bend = DsMap(map).Value(/*"lock_bend"*/ STR(1792));
				if (self->lock_bend > 0)
				{
					switch ((IntType)idInt(self.otherId, bend_part))
					{
						case e_part_LEFT:
						case e_part_RIGHT:
						{
							self->position[X_] -= idVar(self.otherId, bend_offset);
							break;
						}
						case e_part_BACK:
						case e_part_FRONT:
						{
							self->position[Y_] -= idVar(self.otherId, bend_offset);
							break;
						}
						case e_part_LOWER:
						case e_part_UPPER:
						{
							self->position[Z_] -= idVar(self.otherId, bend_offset);
							break;
						}
					}
					
				}
			}
			self->backfaces = value_get_real(DsMap(map).Value(/*"backfaces"*/ STR(1793)), false);
			if (!is_undefined(DsMap(map).Value(/*"bend"*/ STR(1794))))
			{
				VarType bendmap = DsMap(map).Value(/*"bend"*/ STR(1794));
				self->bend_inherit = value_get_real(DsMap(bendmap).Value(/*"inherit_bend"*/ STR(1795)), false);
				if (!is_real(DsMap(bendmap).Value(/*"offset"*/ STR(1796))))
				{
					log({ /*"Missing parameter \"offset\""*/ STR(1797) });
					return null_;
				}
				self->bend_offset = DsMap(bendmap).Value(/*"offset"*/ STR(1796));
				self->bend_end_offset = value_get_real(DsMap(bendmap).Value(/*"end_offset"*/ STR(1798)), IntType(0));
				self->bend_size = value_get_real(DsMap(bendmap).Value(/*"size"*/ STR(978)), null_);
				if (!is_string(DsMap(bendmap).Value(/*"part"*/ STR(871))))
				{
					log({ /*"Missing parameter \"part\""*/ STR(1799) });
					return null_;
				}
				switch (StringType(DsMap(bendmap).Value(/*"part"*/ STR(871))).id)
				{
					case 189: // right
					{
						self->bend_part = e_part_RIGHT;
						self->bend_offset *= self->scale.Value(X_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(X_);
						self->bend_pos_offset = point3D(self->bend_offset, IntType(0), IntType(0));
						break;
					}
					case 188: // left
					{
						self->bend_part = e_part_LEFT;
						self->bend_offset *= self->scale.Value(X_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(X_);
						self->bend_pos_offset = point3D(self->bend_offset, IntType(0), IntType(0));
						break;
					}
					case 1800: // front
					{
						self->bend_part = e_part_FRONT;
						self->bend_offset *= self->scale.Value(Y_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(Y_);
						self->bend_pos_offset = point3D(IntType(0), self->bend_offset, IntType(0));
						break;
					}
					case 1801: // back
					{
						self->bend_part = e_part_BACK;
						self->bend_offset *= self->scale.Value(Y_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(Y_);
						self->bend_pos_offset = point3D(IntType(0), self->bend_offset, IntType(0));
						break;
					}
					case 890: // upper
					{
						self->bend_part = e_part_UPPER;
						self->bend_offset *= self->scale.Value(Z_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(Z_);
						self->bend_pos_offset = point3D(IntType(0), IntType(0), self->bend_offset);
						break;
					}
					case 1802: // lower
					{
						self->bend_part = e_part_LOWER;
						self->bend_offset *= self->scale.Value(Z_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(Z_);
						self->bend_pos_offset = point3D(IntType(0), IntType(0), self->bend_offset);
						break;
					}
					default:
						log({ /*"Invalid parameter \"part\""*/ STR(1803) });
						return null_;
				}
				
				self->bend_axis = ArrType::From({ false, false, false });
				ArrType axis = ArrType();
				if (is_string(DsMap(bendmap).Value(/*"axis"*/ STR(800))))
				{
					switch (StringType(DsMap(bendmap).Value(/*"axis"*/ STR(800))).id)
					{
						case 818: // x
						{
							self->bend_axis.Real(X_) = true;
							array_add(VarType::CreateRef(axis), X_);
							break;
						}
						case 819: // z
						{
							self->bend_axis.Real(Y_) = true;
							array_add(VarType::CreateRef(axis), Y_);
							break;
						}
						case 801: // y
						{
							self->bend_axis.Real(Z_) = true;
							array_add(VarType::CreateRef(axis), Z_);
							break;
						}
						default:
							log({ /*"Invalid parameter \"axis\""*/ STR(1804) });
							return null_;
					}
					
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"axis"*/ STR(800))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"axis"*/ STR(800)))); i++)
						{
							switch (StringType(ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"axis"*/ STR(800))), i)).id)
							{
								case 818: // x
								{
									self->bend_axis.Real(X_) = true;
									array_add(VarType::CreateRef(axis), X_);
									break;
								}
								case 819: // z
								{
									self->bend_axis.Real(Y_) = true;
									array_add(VarType::CreateRef(axis), Y_);
									break;
								}
								case 801: // y
								{
									self->bend_axis.Real(Z_) = true;
									array_add(VarType::CreateRef(axis), Z_);
									break;
								}
								default:
									log({ /*"Invalid parameter \"axis\""*/ STR(1804) });
									return null_;
							}
							
						}
					}
					else
					{
						log({ /*"Missing parameter \"axis\""*/ STR(1805) });
						return null_;
					}
				
				
				self->bend_direction_min = vec3(-IntType(180));
				if (is_real(DsMap(bendmap).Value(/*"direction_min"*/ STR(1806))) && array_length(VarType::CreateRef(axis)) == IntType(1))
				{
					self->bend_direction_min.Real(axis.Value(IntType(0))) = DsMap(bendmap).Value(/*"direction_min"*/ STR(1806));
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"direction_min"*/ STR(1806))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"direction_min"*/ STR(1806)))); i++)
							self->bend_direction_min.Real(axis.Value(i)) = ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"direction_min"*/ STR(1806))), i);
					}
				
				self->bend_direction_max = vec3(IntType(180));
				if (is_real(DsMap(bendmap).Value(/*"direction_max"*/ STR(1807))) && array_length(VarType::CreateRef(axis)) == IntType(1))
				{
					self->bend_direction_max.Real(axis.Value(IntType(0))) = DsMap(bendmap).Value(/*"direction_max"*/ STR(1807));
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"direction_max"*/ STR(1807))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"direction_max"*/ STR(1807)))); i++)
							self->bend_direction_max.Real(axis.Value(i)) = ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"direction_max"*/ STR(1807))), i);
					}
				
				self->bend_direction = ArrType::From({ IntType(0), IntType(0), IntType(0) });
				self->bend_direction_legacy = false;
				if (is_string(DsMap(bendmap).Value(/*"direction"*/ STR(898))))
				{
					switch (StringType(DsMap(bendmap).Value(/*"direction"*/ STR(898))).id)
					{
						case 1808: // forward
						{
							self->bend_direction.Real(axis.Value(IntType(0))) = e_bend_FORWARD;
							break;
						}
						case 1809: // backward
						{
							self->bend_direction.Real(axis.Value(IntType(0))) = e_bend_BACKWARD;
							break;
						}
						case 1810: // both
						{
							self->bend_direction.Real(axis.Value(IntType(0))) = e_bend_BOTH;
							break;
						}
						default:
							log({ /*"Invalid parameter \"direction\""*/ STR(1811) });
							return null_;
					}
					
					self->bend_direction_legacy = true;
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"direction"*/ STR(898))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"direction"*/ STR(898)))); i++)
						{
							switch (StringType(ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"direction"*/ STR(898))), i)).id)
							{
								case 1808: // forward
								{
									self->bend_direction.Real(axis.Value(i)) = e_bend_FORWARD;
									break;
								}
								case 1809: // backward
								{
									self->bend_direction.Real(axis.Value(i)) = e_bend_BACKWARD;
									break;
								}
								case 1810: // both
								{
									self->bend_direction.Real(axis.Value(i)) = e_bend_BOTH;
									break;
								}
								default:
									log({ /*"Invalid parameter \"direction\""*/ STR(1811) });
									return null_;
							}
							
							self->bend_direction_legacy = true;
						}
					}
				
				if ((is_real(DsMap(bendmap).Value(/*"invert"*/ STR(1812))) || is_bool(DsMap(bendmap).Value(/*"invert"*/ STR(1812)))) && array_length(VarType::CreateRef(axis)) == IntType(1))
				{
					self->bend_invert = vec3(DsMap(bendmap).Value(/*"invert"*/ STR(1812)));
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"invert"*/ STR(1812))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"invert"*/ STR(1812)))); i++)
							self->bend_invert.Real(axis.Value(i)) = ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"invert"*/ STR(1812))), i);
					}
					else
						self->bend_invert = vec3(false);
				
				
				if (self->bend_direction_legacy)
				{
					for (IntType i = X_; i <= Z_; i++)
					{
						if (self->bend_direction.Real(i) == e_bend_BOTH)
						{
							self->bend_direction_min.Real(i) = -IntType(180);
							self->bend_direction_max.Real(i) = IntType(180);
						}
						else
							if (self->bend_direction.Real(i) == e_bend_FORWARD)
							{
								self->bend_direction_min.Real(i) = IntType(0);
								self->bend_direction_max.Real(i) = IntType(180);
								self->bend_invert.Real(i) = !self->bend_invert.Real(i);
							}
							else
							{
								self->bend_direction_min.Real(i) = IntType(0);
								self->bend_direction_max.Real(i) = IntType(180);
							}
						
						
					}
				}
				self->bend_default_angle.Real(Z_) = IntType(0);
				if (is_real(DsMap(bendmap).Value(/*"angle"*/ STR(816))) && array_length(VarType::CreateRef(axis)) == IntType(1))
				{
					self->bend_default_angle = vec3(DsMap(bendmap).Value(/*"angle"*/ STR(816)));
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"angle"*/ STR(816))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"angle"*/ STR(816)))); i++)
							self->bend_default_angle.Real(axis.Value(i)) = ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"angle"*/ STR(816))), i);
					}
				
				self->bend_inherit_angle.Real(Z_) = IntType(0);
				if (self->bend_inherit > 0 && Obj(self.otherId)->subAssetId == ID_obj_model_part)
					self->bend_inherit_angle = point3D_add(self->bend_default_angle, idVec(self.otherId, bend_inherit_angle));
				else
					self->bend_inherit_angle = self->bend_default_angle;
				
				self->ik_supported = tl_supports_ik(ScopeAny(self), false);
			}
			else
			{
				self->bend_part = null_;
				self->bend_axis.Real(Z_) = false;
				self->bend_direction.Real(Z_) = IntType(0);
				self->bend_default_angle.Real(Z_) = IntType(0);
				self->bend_inherit_angle.Real(Z_) = IntType(0);
				self->bend_inherit = false;
				self->bend_offset = IntType(0);
				self->bend_end_offset = IntType(0);
				self->bend_size = null_;
				self->bend_invert.Real(Z_) = false;
				self->bend_pos_offset = vec3(IntType(0));
				self->bend_direction_min = vec3(-IntType(180));
				self->bend_direction_max = vec3(IntType(180));
				self->ik_supported = false;
			}
			
			self->matrix = matrix_create(point3D(IntType(0), IntType(0), IntType(0)), self->rotation, vec3(IntType(1)));
			self->default_matrix = matrix_create(self->position, self->rotation, vec3(IntType(1)));
			if (Obj(self.otherId)->subAssetId == ID_obj_model_part && self->lock_bend > 0 && idInt(self.otherId, bend_part) != null_)
				self->default_matrix = matrix_multiply(self->default_matrix, model_part_get_bend_matrix(ScopeAny(self), { self.otherId, idVec(self.otherId, bend_inherit_angle), point3D(IntType(0), IntType(0), IntType(0)) }));
			self->bounds_start = point3D(no_limit, no_limit, no_limit);
			self->bounds_end = point3D(-no_limit, -no_limit, -no_limit);
			self->has_3d_plane = false;
			VarType shapelist = DsMap(map).Value(/*"shapes"*/ STR(1813));
			if (ds_list_valid(shapelist))
			{
				self->shape_list = ds_list_create();
				for (IntType p = IntType(0); p < ds_list_size((IntType)(shapelist)); p++)
				{
					VarType shape = model_file_load_shape(self, DsList(shapelist).Value(p), res);
					if (shape == null_)
						return null_;
					if (shape > IntType(0))
						ds_list_add({ self->shape_list, shape });
				}
			}
			else
				self->shape_list = null_;
			
			self->bounds_parts_start = self->bounds_start;
			self->bounds_parts_end = self->bounds_end;
			VarType partlist = DsMap(map).Value(/*"parts"*/ STR(1772));
			if (ds_list_valid(partlist))
			{
				self->part_list = ds_list_create();
				for (IntType p = IntType(0); p < ds_list_size((IntType)(partlist)); p++)
				{
					VarType part = model_file_load_part(ScopeAny(self), DsList(partlist).Value(p), root, res, model);
					if (part == null_)
						return null_;
					if (part > IntType(0))
						ds_list_add({ self->part_list, part });
				}
			}
			else
				self->part_list = null_;
			
			VecType boundsstartdef, boundsenddef;
			boundsstartdef = point3D_mul_matrix(self->bounds_parts_start, self->default_matrix);
			boundsenddef = point3D_mul_matrix(self->bounds_parts_end, self->default_matrix);
			idVec(self.otherId, bounds_parts_start).Real(X_) = min({ idVec(self.otherId, bounds_parts_start).Real(X_), boundsstartdef.Real(X_) });
			idVec(self.otherId, bounds_parts_start).Real(Y_) = min({ idVec(self.otherId, bounds_parts_start).Real(Y_), boundsstartdef.Real(Y_) });
			idVec(self.otherId, bounds_parts_start).Real(Z_) = min({ idVec(self.otherId, bounds_parts_start).Real(Z_), boundsstartdef.Real(Z_) });
			idVec(self.otherId, bounds_parts_end).Real(X_) = max({ idVec(self.otherId, bounds_parts_end).Real(X_), boundsenddef.Real(X_) });
			idVec(self.otherId, bounds_parts_end).Real(Y_) = max({ idVec(self.otherId, bounds_parts_end).Real(Y_), boundsenddef.Real(Y_) });
			idVec(self.otherId, bounds_parts_end).Real(Z_) = max({ idVec(self.otherId, bounds_parts_end).Real(Z_), boundsenddef.Real(Z_) });
			ds_list_add({ ObjType(obj_model_file, root)->file_part_list, self->id });
			if (self->has_3d_plane)
				ObjType(obj_model_file, root)->has_3d_plane = true;
			return self->id;
		}
		
		return VarType();
	}
	
}
